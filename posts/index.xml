<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on Notes</title>
		<link>https://prabowo02.github.io/posts/</link>
		<description>Recent content in Posts on Notes</description>
		<generator>Hugo 0.60.0 -- gohugo.io</generator>
		<language>en-us</language>
		<lastBuildDate>Tue, 01 Jun 2021 23:08:09 +0800</lastBuildDate>
		<atom:link href="https://prabowo02.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		<item>
			<title>Sum of $C(N, i) \times i^K$</title>
			<link>https://prabowo02.github.io/posts/sum-cnk-xk/</link>
			<pubDate>Tue, 01 Jun 2021 23:08:09 +0800</pubDate>
			<guid isPermaLink="true">https://prabowo02.github.io/posts/sum-cnk-xk/</guid>
			<description>&lt;p&gt;Have you ever been doing your grocery then suddenly felt the need to compute:&lt;/p&gt;
&lt;p&gt;$$\sum_{i=0}^N \binom{N}{i} i^K $$&lt;/p&gt;
&lt;p&gt;where $N \le 10^9$ and $K \le 10^5$? Well you are in luck, because I&#39;m about to show you how.&lt;/p&gt;
&lt;p&gt;Consider the binomial expansion:&lt;/p&gt;
&lt;p&gt;$$f_0(x) := (1 + x)^N = \sum_{i=0}^N \binom{N}{i} x^i$$&lt;/p&gt;
&lt;p&gt;If you differentiate then multiply by $x$, you will get:&lt;/p&gt;
&lt;p&gt;$$f_1(x) := x \frac{d}{dx}(1 + x)^N = \sum_{i=0}^N \binom{N}{i}\cdot i \cdot x^i$$&lt;/p&gt;
&lt;p&gt;Then repeatedly differentiate and multiply by $x$ (i.e. $f_k(x) = x \frac{d}{dx} f_{k - 1}(x)$), then you will end up with:&lt;/p&gt;
&lt;p&gt;$$f_K(x) = \sum_{i=0}^N \binom{N}{i} i^K x^i$$&lt;/p&gt;
&lt;p&gt;Evaluate $f_K(1)$ then you will get the answer to the original question.&lt;/p&gt;
&lt;p&gt;The value of $f_K$ is actually:&lt;/p&gt;
&lt;p&gt;$$f_K(x) = \sum_{i=0}^K S(K, i) \cdot \binom{N}{i} \cdot i! \cdot 2^{N-i} \cdot x^i$$&lt;/p&gt;
&lt;p&gt;where $S$ is the Stirling number of the second kind.
The formula can be easily shown using induction following the property $S(N, K) = K \cdot S(N - 1, K) + S(N - 1, K - 1)$.&lt;/p&gt;
&lt;p&gt;The computation of $\binom{N}{i} i!$ for all $0 \le i \le K$ can be easily computed in $O(K)$, and the computation of $S(K, i)$ can be done using FFT (&lt;a href=&#34;https://en.wikipedia.org/wiki/Touchard_polynomials&#34;&gt;Touchard Polynomial&lt;/a&gt;) in $O(K \log K)$.&lt;/p&gt;
&lt;p&gt;In case you need something more general:&lt;/p&gt;
&lt;p&gt;$$\sum_{i=0}^N \binom{N}{i} \cdot i^K \cdot A^i \cdot B^{N - i} = \sum_{i=0}^K S(K, i) \cdot \binom{N}{i} \cdot i! \cdot A^i \cdot (1 + B)^{N - i}$$&lt;/p&gt;
&lt;p&gt;which can actually be obtained by starting the initial equation from $(B + x)^N$ and substitute $x = A$.&lt;/p&gt;
&lt;p&gt;You can now solve &lt;a href=&#34;https://codeforces.com/problemset/problem/1278/F&#34;&gt;this problem&lt;/a&gt; for $K \le 10^5$.&lt;/p&gt;
</description>
		</item>
		<item>
			<title>Notes on Fast Fourier Transform</title>
			<link>https://prabowo02.github.io/posts/fft/</link>
			<pubDate>Thu, 17 Dec 2020 17:55:15 +0800</pubDate>
			<guid isPermaLink="true">https://prabowo02.github.io/posts/fft/</guid>
			<description>&lt;p&gt;This is not a tutorial. It&#39;s just an overview for those who already (hopefully) understood FFT.
(Actually, more of a personal note to myself)&lt;/p&gt;
&lt;h3 id=&#34;so-what-is-fft&#34;&gt;So what is FFT?&lt;/h3&gt;
&lt;p&gt;DFT but fast&lt;/p&gt;
&lt;h3 id=&#34;what-dft-does&#34;&gt;What DFT does?&lt;/h3&gt;
&lt;p&gt;Converts a polynomial into point value forms where the points sampled are principal $n$-th root of unity.&lt;/p&gt;
&lt;h3 id=&#34;can-you-inverse-the-transformation&#34;&gt;Can you inverse the transformation?&lt;/h3&gt;
&lt;p&gt;Yes, by doing the exact same thing as DFT but the sampled points are inverted too, then divide the final result by $n$.&lt;/p&gt;
&lt;h3 id=&#34;how-to-do-dft&#34;&gt;How to do DFT?&lt;/h3&gt;
&lt;p&gt;Evaluate each sample point in $O(N)$, and you end up in $O(N^2)$ transformation.&lt;/p&gt;
&lt;h3 id=&#34;can-you-do-better&#34;&gt;Can you do better?&lt;/h3&gt;
&lt;p&gt;Yes, that&#39;s when FFT comes in.&lt;/p&gt;
&lt;h3 id=&#34;how-to-fft&#34;&gt;How to FFT?&lt;/h3&gt;
&lt;p&gt;The most commonly used algorithm is Cooley-Tukey algorithm, and the DFT size is usually taken in the form of $2^k$. It is basically a Divide and Conquer algorithm, by separating the odd and even terms, and does FFT recursively. By doing some reordering using bit reversal, you can actually does an iterative version of it. Final complexity is $O(N \log N)$ without any additional space.
Details on FFT can be found in this &lt;a href=&#34;https://codeforces.com/blog/entry/43499&#34;&gt;Codeforces blog&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;how-does-fft-help-to-solve-problems&#34;&gt;How does FFT help to solve problems?&lt;/h3&gt;
&lt;p&gt;The main idea is sum-convolution (can also be viewed as polynomial multiplication). That is, given two sequences $a$ and $b$, for each pair of $i$, $j$, $a_i \times b_j$ is &amp;ldquo;contributed&amp;rdquo; to $c_{i + j}$, where $c$ is the convolution.
The way to do that is: $c = IFFT(FFT(a) * FFT(b))$, where $*$ is point-wise multiplication.&lt;/p&gt;
&lt;p&gt;Note that by default DFT is a cyclic convolution, i.e. $a_i b_j$ is actually contributed to $c_{(i + j) \bmod n}$ (in other words, the multiplication is in modulo $(x^n - 1)$). Therefore, to avoid &amp;ldquo;overflow&amp;rdquo;, you pad the polynoms with $0$s until the polynom size is of size $2^k ≥ |a| + |b|$.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://open.kattis.com/problems/aplusb&#34;&gt;An example problem&lt;/a&gt; on how FFT helps. For this problem, you create a polynom where the coefficient of $x^i$ is the number of elements in a that are equal to $i$. After that, you square the polynomial, then start processing from there.&lt;/p&gt;
&lt;p&gt;Sometimes FFT is closely related to string &amp;ldquo;matching&amp;rdquo; too. In this case, usually each alphabet is associated with a polynom where coefficient $x^i$ equals to $1$ if $s_i$ is equal to the associated alphabet, or $0$ otherwise. Here is &lt;a href=&#34;https://codeforces.com/problemset/problem/528/D&#34;&gt;an example&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Another time, a DP problem can be optimized using FFT too. This can be noticed when the transition is $O(N)$ and looks like a convolution. In the case of DP, often we mention the polynomial as (Ordinary) Generating Function. The coefficients of the OGF will be of the interest when arriving at the final answer.&lt;/p&gt;
&lt;p&gt;Talking about generating functions, there is also something called Exponential Generating Function. In EGF, the coefficient of $x^i$ is $\frac{\text{actual value}}{i!}$. And when you multiply, the contributed value is $\binom{i + j}{i} a_i b_j$.&lt;/p&gt;
&lt;h3 id=&#34;what-are-some-popular-generating-functions&#34;&gt;What are some popular generating functions?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;$(1 + x)^n$. OGF for binomial coefficients $(\binom{n}{0}, \binom{n}{1}, \dots, \binom{n}{n})$.&lt;/li&gt;
&lt;li&gt;$\frac{1}{1 - x}$. OGF for $(1, 1, \dots)$. This is handy if you want to get the &amp;ldquo;prefix sum&amp;rdquo; of a GF by simply divides it by $(1 - x)$.&lt;/li&gt;
&lt;li&gt;$\frac{1}{(1 - x)^k}$. OGF for $(\kern-.5em(\genfrac{}{}{0pt}{}{n}{k})\kern-.5em) = \binom{n + k - 1}{k - 1}$. Used for counting multisets.&lt;/li&gt;
&lt;li&gt;$\frac{x^k}{(1 - x)^{k + 1}}$. OGF for $\binom{n}{k}$. The &amp;ldquo;column&amp;rdquo; of binomial cofficients.&lt;/li&gt;
&lt;li&gt;$y = xy + xy^2 + 1 \implies y = \frac{1}{1 - x - x^2}$. OGF for Fibonacci number.&lt;/li&gt;
&lt;li&gt;$y = 1 + xy^2 \implies y = \frac{2}{1 + \sqrt{1 - 4x}}$. OGF for Catalan number.&lt;/li&gt;
&lt;li&gt;$\exp(x)$. EGF for $(1, 1, \dots)$.&lt;/li&gt;
&lt;li&gt;$\exp(\exp(x) - 1)$. EGF for Bell numbers. It can be used to count number of set partitions.&lt;/li&gt;
&lt;li&gt;$\prod_{i=0}^{n-1}(x + i)$. OGF for Stirling number first kind.&lt;/li&gt;
&lt;li&gt;$\exp(-x) \sum_{i=0}^n \frac{i^n x^i}{i!}$. OGF for Stirling number second kind, also known as Touchard polynomial.&lt;/li&gt;
&lt;li&gt;$\frac{(-\log(1 - x))^k}{k!}$. EGF for &amp;ldquo;column&amp;rdquo; Stirling number first kind. Note that $-\log(1 - x) = \sum \frac{x^i}{i}$.&lt;/li&gt;
&lt;li&gt;$\frac{(\exp(x) - 1)^k}{k!}$. EGF for &amp;ldquo;column&amp;rdquo; Stirling number second kind.&lt;/li&gt;
&lt;li&gt;$y \exp(y) = x$. Lambert W function. Also EGF for number of rooted enumerated trees. Can be computed using Lagrange–Bürmann formula.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;why-are-there-divisions-and-exponent&#34;&gt;Why are there divisions and exponent?&lt;/h3&gt;
&lt;p&gt;These are operations on formal power series. The idea is, if you want to compute $Q$ that satisfies $f(Q) = 0$, for some polynom $Q$ and function $f$, we can use the Newton&#39;s method $Q_{n+1} = Q_n - \frac{f(P)}{f&amp;rsquo;(P)}$.&lt;/p&gt;
&lt;p&gt;For example, computing $Q = \frac{1}{P} \implies Q^{-1} - P = 0 \implies f(Q) = Q^{-1} - P$&lt;br&gt;
$Q := Q - \frac{Q^{-1} - P}{-Q^{-2}} = Q + (Q - PQ) = 2Q - PQ^2$&lt;/p&gt;
&lt;p&gt;Another example, computing $Q = \sqrt{P} \implies Q^2 - P = 0 \implies f(Q) = Q^2 - P$&lt;br&gt;
$Q := Q - \frac{Q^2 - P}{2Q} = \frac{1}{2}(Q + \frac{P}{Q})$&lt;/p&gt;
&lt;p&gt;In every iteration of the Newton&#39;s method, the precision is doubled, i.e. the degree of $Q$ is improved from $n$ to $2n + 1$, and initially $Q$ is only a constant.&lt;/p&gt;
&lt;p&gt;And here are several operations along with their tricks:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Additions and subtractions are obvious.&lt;/li&gt;
&lt;li&gt;Multiplication done by FFT.&lt;/li&gt;
&lt;li&gt;Differentiation and integral are straightforward.&lt;/li&gt;
&lt;li&gt;$\frac{1}{P}$, $\sqrt{P}$, $\exp(P)$ can be done using Newton&#39;s method.&lt;/li&gt;
&lt;li&gt;$\log(P) = \int \frac{P&amp;rsquo;}{P}$&lt;/li&gt;
&lt;li&gt;$P(x)^a = \exp(a \log(P(x)))$&lt;/li&gt;
&lt;li&gt;$\arctan(P) = \int \frac{1}{1 + P^2}$&lt;/li&gt;
&lt;li&gt;Generally, inverse trigonometric function can be computed from &lt;a href=&#34;https://en.wikipedia.org/wiki/Inverse_trigonometric_functions#Derivatives_of_inverse_trigonometric_functions&#34;&gt;their derivatives&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;$P^{-1}(x)$ i.e. the inverse function, can be done using Lagrange–Bürmann formula&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;what-about-modulo&#34;&gt;What about modulo?&lt;/h3&gt;
&lt;p&gt;You can find the details of division, modulo, multipoint evaluation, and interpolation in &lt;a href=&#34;https://drive.google.com/file/d/1B9BIfATnI_qL6rYiE5hY9bh20SMVmHZ7/view&#34;&gt;adamant&#39;s lecture note&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;do-the-points-must-be-roots-of-unity&#34;&gt;Do the points must be roots of unity?&lt;/h3&gt;
&lt;p&gt;You can actually compute for $\{{z^i\}}_{i=0}^{n-1}$, for any complex number $z$. This is called Chirp Z-transform and can be done using Bluestein&#39;s algorithm. The main idea is to write $ij = \binom{i + j}{2} - \binom{i}{2} - \binom{j}{2}$.&lt;br&gt;
Hence, $\sum(a_i z^{ik}) = \sum \left(a_i z^{-\binom{i}{2}} z^{\binom{i + k}{2}} \right) z^{-\binom{k}{2}}$, which is exactly a convolution and can be computed using FFT. &lt;a href=&#34;https://codeforces.com/problemset/problem/1054/H&#34;&gt;Example problem&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;can-we-compute-any-size-dft-quickly&#34;&gt;Can we compute any size DFT quickly?&lt;/h3&gt;
&lt;p&gt;Yes, by using CZT, and $z$ such that $z$ is primitive $n$-th root of unity where $n$ is the DFT size. One example problem that use DFT any size can be found on &lt;a href=&#34;https://codeforces.com/contest/901/problem/E&#34;&gt;Codeforces&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;must-the-polynomial-be-monic&#34;&gt;Must the polynomial be monic?&lt;/h3&gt;
&lt;p&gt;Multidimentional DFT can be done by performing DFT on each dimension one by one. An example problem can be found &lt;a href=&#34;https://codeforces.com/gym/102441/problem/E&#34;&gt;here&lt;/a&gt;. In this problem, &lt;span style=&#34;color:white&#34;&gt;you will need both sum-convolution for one variable, and xor-convolution for the other in a single polynomial&lt;/span&gt; (spoiler in white text).&lt;/p&gt;
&lt;h3 id=&#34;xorconvolution&#34;&gt;Xor-convolution?&lt;/h3&gt;
&lt;p&gt;Xor convolution means that $a_i b_j$ is contributed to $c_{i \oplus j}$. It is basically the standard DFT but multidimensional, and each dimension is DFT of size $2$. This is working because xor is basically addition in vector space $\bmod 2$.&lt;/p&gt;
&lt;h3 id=&#34;can-we-have-other-bitwise-convolutions&#34;&gt;Can we have other bitwise convolutions?&lt;/h3&gt;
&lt;p&gt;In XOR, you tranform $(u, v)$ to $(u + v, u - v)$.&lt;br&gt;
In AND, you tranform $(u, v)$ to $(u + v, v)$. After performing AND-tranform, you actually ends up with sum of supermasks.&lt;br&gt;
In OR, you tranform $(u, v)$ to $(u, u + v)$. After performing OR-tranform, you actually ends up with sum of submasks.&lt;br&gt;
In NAND, you perform AND, then do the bit inverting (i.e. swap coefficients of bit 0 and bit 1).&lt;/p&gt;
&lt;p&gt;An example problem that uses various binary gates can be found on &lt;a href=&#34;https://codeforces.com/contest/1033/problem/F&#34;&gt;Codeforces&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;must-dft-be-operated-in-complex&#34;&gt;Must DFT be operated in complex?&lt;/h3&gt;
&lt;p&gt;DFT works over an arbitrary ring, as long as you are using the principal $n$-th root of unity as the sampled points. Primitive $n$-th root is also principal $n$-th root. Since primitive roots are roots of the $n$-th cyclotomic polynomial, by ensuring your points satisfy $\Phi_n(x) = 0$, then DFT should work. &lt;a href=&#34;https://codeforces.com/problemset/problem/1103/E&#34;&gt;An example problem&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;can-we-compute-the-product-of-multiple-polynomials&#34;&gt;Can we compute the product of multiple polynomials?&lt;/h3&gt;
&lt;p&gt;Suppose that the sum of degrees of the given polynomials is $N$, then we can do either of the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use priority queue, and compute the multiplication of every two polynomials with the lowest degrees.&lt;/li&gt;
&lt;li&gt;Use Divide and Conquer, then split the polynomials to sum of degrees approximately N/2, then recurse&lt;/li&gt;
&lt;li&gt;Divide and Conquer, then split half of the polynomials, regardless of the degrees&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All of these run in $O(N \log^2 N)$. &lt;a href=&#34;https://codeforces.com/problemset/problem/1257/G&#34;&gt;This problem&lt;/a&gt; require this technique.&lt;/p&gt;
</description>
		</item>
		<item>
			<title>Factorial mod prime</title>
			<link>https://prabowo02.github.io/posts/factorial-mod-p/</link>
			<pubDate>Mon, 02 Nov 2020 18:00:15 +0800</pubDate>
			<guid isPermaLink="true">https://prabowo02.github.io/posts/factorial-mod-p/</guid>
			<description>&lt;p&gt;We are to compute $n! \bmod p$ in $O(\sqrt{p} \log p)$, where $p$ prime.&lt;/p&gt;
&lt;h2 id=&#34;basic-idea&#34;&gt;Basic Idea&lt;/h2&gt;
&lt;p&gt;If we define the polynomial $f(x) := \prod_{i=1}^n (x + i)$, then we can write $n! = f(0)$.&lt;/p&gt;
&lt;p&gt;Let $v := \lfloor \sqrt n \rfloor$ and $g(x) := \prod_{i=1}^v (x+i)$, then&lt;/p&gt;
&lt;p&gt;$$ n! = \left( \prod_{i=0}^{v-1} g(vi) \right) \prod_{i=v^2 + 1}^n i $$&lt;/p&gt;
&lt;p&gt;The latter part of the product can be computed in $O(\sqrt p)$. We will try to find a fast way to compute
$g(0), g(v), \dots, g(v(v-1))$.&lt;/p&gt;
&lt;h2 id=&#34;method&#34;&gt;Method&lt;/h2&gt;
&lt;h3 id=&#34;1-osqrt-p-log-p2&#34;&gt;1. $O(\sqrt p (\log p)^2)$&lt;/h3&gt;
&lt;p&gt;Using FFT multipoint evaluation, we can compute $g(0), \dots, g(v(v+1))$ simultaneously. However, this algorithm uses a lot of polynomial division, which has heavy constant factor, and the speed will not be much faster than $O(p)$.&lt;/p&gt;
&lt;h3 id=&#34;2-osqrt-p-log-p&#34;&gt;2. $O(\sqrt p \log p)$&lt;/h3&gt;
&lt;p&gt;$g(x)$ has roots $-1, -2, \dots, -v$ which is an arithmetic progression, and we want to evaluate $g(x)$ at $0, v, \dots, v(v-1)$ which is also an arithmetic progression. In this case, we will make use of Lagrange Interpolation.&lt;/p&gt;
&lt;p&gt;Next, for a fixed $d$, we define $g_d(x) := \prod_{i=1}^d (x+i)$. Suppose we are able to compute $g_d(0), g_d(v), \dots, g_d(dv)$, then we can compute $g_{2d}(0), g_{2d}(v), \dots, g_{2d}(2dv)$ in $O(d \log d)$. If we are able to achieve this, then we can achieve the desired complexity.&lt;/p&gt;
&lt;p&gt;Notice that $g_{2d}(x) = g_d(x) \cdot g_d(x + d)$. Let $G_d(i) := (g_d(i), g_d(v+i), \dots, g_d(dv + i))$, then from $G_d(0)$, we want to interpolate $G_d(d), G_d(dv), G_d(dv + d)$. This can be achieved using Lagrange Interpolation and FFT (NTT) in $O(d \log d)$ as described below.&lt;/p&gt;
&lt;p&gt;Let $h(x)$ be a $d$-degree polynomial and the values $h(0), h(1), \dots, h(d)$ are known, then the value $h(m + k)$ can be computed using Lagrange Interpolation (assuming $m + k - j$ has an inverse):&lt;/p&gt;
&lt;p&gt;$$
\begin{align*}
h(m + k) &amp;amp;= \sum_{i = 0}^d h(i) \prod_{j=0, i \neq j}^d \frac{m+k-j}{i-j} \\\&lt;br&gt;
&amp;amp;= \left(\prod_{j=0}^d (m + k - j) \right) \left( \sum_{i=0}^d \frac{h(i)}{i! (d-i)! (-1)^{d-i}} \cdot \frac{1}{m + k - i} \right)
\end{align*}
$$&lt;/p&gt;
&lt;p&gt;Notice that the right parenthesis is actually a convolution, so $h(m), h(m+1), \dots, h(m+d)$ can be computed in $O(d \log d)$. To interpolate $G_d(a)$ from $G_d(0)$, it is enough to substitute $m := av^{-1}$.&lt;/p&gt;
&lt;p&gt;From the above, $n! \bmod p$ can be computed in $O(\sqrt p \log p)$.&lt;/p&gt;
</description>
		</item>
		<item>
			<title>Project Euler #100</title>
			<link>https://prabowo02.github.io/posts/project-euler-100/</link>
			<pubDate>Fri, 10 Jul 2020 00:24:26 +0800</pubDate>
			<guid isPermaLink="true">https://prabowo02.github.io/posts/project-euler-100/</guid>
			<description>&lt;p&gt;This post will give the analysis to &lt;a href=&#34;https://www.hackerrank.com/contests/projecteuler/challenges/euler100/problem&#34;&gt;Project Euler #100&lt;/a&gt; from hackerrank, which is an extended version from the &lt;a href=&#34;https://projecteuler.net/problem=100&#34;&gt;original&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;problem&#34;&gt;Problem&lt;/h2&gt;
&lt;p&gt;Given $P$, $Q$, and $M$, find smallest $n$ such that $\frac{b(b-1)}{n(n-1)} = \frac{P}{Q}$, where $b$ and $n$ are positive integers and $n &amp;gt; M$.&lt;/p&gt;
&lt;p&gt;Constraints:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$2 ≤ M ≤ 10^{15}$.&lt;/li&gt;
&lt;li&gt;$0 &amp;lt; P &amp;lt; Q ≤ 10^7$.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;
&lt;p&gt;To simplify matters, we assume $P$ and $Q$ are coprime. If they are not, simply divide both of them with their gcd.
The equation $\frac{b(b-1)}{n(n-1)} = \frac{P}{Q}$ can be rewritten as $Q(b(b-1)) = P(n(n-1)) \Rightarrow Q(2b-1)^2 - P(2n-1)^2 = Q - P$ by completing the square.&lt;/p&gt;
&lt;p&gt;Let $Q = qr^2$ where $r$ is the largest divisor of $Q$ such that $r^2 | Q$. Therefore $q$ is squarefree.
Multiplying both sides of the equation with $q$, we obtain:&lt;/p&gt;
&lt;p&gt;$$(qr(2b-1))^2 - Pq(2n-1)^2 = q(Q-P)$$&lt;/p&gt;
&lt;p&gt;Notice that this is actually the generalized Pell equation $x^2 - Dy^2 = N$, with $D = Pq$ and $N = q(Q-P)$.
Some readers may notice that multiplying both sides with $Q$ instead of $q$ will make the equation looks easier, but the reason to that may have to wait until the next few parts of the solution.&lt;/p&gt;
&lt;p&gt;There are two cases when solving the Pell equation $x^2 - Dy^2 = N$:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$D$ is a square.&lt;/li&gt;
&lt;li&gt;$D$ is not a square.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;d-is-a-square&#34;&gt;$D$ is a square&lt;/h3&gt;
&lt;p&gt;If $D$ is a square, that means $Pq$ is a square, or equivalently $PQ$ is also a square.
Let $d = \sqrt{PQ}$, $x = Q(2b-1)$, $y = (2n-1)$, then we can rewrite the equation $x^2 - PQy^2 = Q(Q-P)$ as:&lt;/p&gt;
&lt;p&gt;$(x - dy)(x + dy) = Q(Q-P)$&lt;/p&gt;
&lt;p&gt;Factoring $Q(Q-P)$ into $a \times b$ where $a$ and $b$ are integers, we solve these two simultaneous linear equations:&lt;/p&gt;
&lt;p&gt;$$x - dy = a$$
$$x + dy = b$$&lt;/p&gt;
&lt;p&gt;After solving these two equations for all $a$ and $b$, we obtain all solutions to $x$ and $y$. Hence, $b$ and $n$ can also be determined.&lt;/p&gt;
&lt;h3 id=&#34;d-is-not-a-square&#34;&gt;$D$ is not a square&lt;/h3&gt;
&lt;p&gt;If $D$ is not a square, apply the LMM algorithm (&lt;a href=&#34;http://www.jpr2718.org/pell.pdf&#34;&gt;Solving the generalized Pell equation by John P. Robertson&lt;/a&gt; page 16). The first part of the algorithm is to find all $z$ such that $z^2 = D \pmod {|m|}$ where $m = \frac{N}{f^2}$ and $f^2 | N$. Finding such $z$ may be hard in general, but there are a few special property on this specific equation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It can be seen that $q$ and $Q-P$ are coprime. Therefore we can split the congruence into two congruences and merge them later using CRT (Chinese Remainder Theorem).&lt;/li&gt;
&lt;li&gt;$f^2$ only divides $Q-P$ because $q$ is squarefree. Therefore we do not need to consider the divisors of $q$ when considering the equation $x^2 = Pq \mod q$.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;solving-x2--pq-mod-q&#34;&gt;Solving $x^2 = Pq \mod q$&lt;/h4&gt;
&lt;p&gt;It is obvious that $Pq = 0 \mod q$ because $q | Pq$. The congruence became $x^2 = 0 mod q$. Since q is squarefree, there is only one solution to $x$, which is $0$ (how convenient). This is the reason why we are not using the equation $x^2 - PQ = Q(Q-P)$, because solving $x^2 = 0 \mod Q$ may yield tens or hundreds of solutions.&lt;/p&gt;
&lt;h4 id=&#34;solving-x2--pq-mod-qp&#34;&gt;Solving $x^2 = Pq \mod (Q-P)$&lt;/h4&gt;
&lt;p&gt;First, rewrite the congruence:&lt;/p&gt;
&lt;p&gt;$ \ \ \ \ \ \ \  x^2 = Pq \pmod{Q-P}$&lt;br&gt;
$\Longrightarrow x^2 = Pq + q(Q-P) \pmod{Q-P}$&lt;br&gt;
$\Longrightarrow x^2 = Qq \pmod {Q-P}$&lt;br&gt;
$\Longrightarrow x^2 = (qr)^2 \pmod{Q-P}$&lt;/p&gt;
&lt;p&gt;This also works when the modulo is $\frac{Q-P}{f^2}$, we will obtain the same congruence $x^2 = (qr)^2 \pmod{\frac{Q-P}{f^2}}$.&lt;/p&gt;
&lt;p&gt;Since we already know one solution to $x$ (which is $qr$), then the other solutions can be determined quite easily.&lt;/p&gt;
&lt;p&gt;To solve $x^2 = a^2 \pmod m$, factor $m$ into its prime factors $p_1^{k_1} \times p_2^{k_2} \times \ldots \times p_n^{k_n}$.
Then solve $x^2 = a^2 \pmod{p^k}$ for each prime factor $p$ of $m$. Lastly, merge them using CRT.
Since $qr$ and $Q-P$ are coprime, we assume that $a$ and $m$ are coprime too.&lt;/p&gt;
&lt;h5 id=&#34;solving-x2--a2-pmod-2k&#34;&gt;Solving $x^2 = a^2 \pmod {2^k}$&lt;/h5&gt;
&lt;p&gt;Three cases:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$k = 1$: Only one solution to $x$, namely $x = 1$.&lt;/li&gt;
&lt;li&gt;$k = 2$: Two solutions, namely $x = 1$ and $x = 3$.&lt;/li&gt;
&lt;li&gt;$k &amp;gt; 2$: Four solutions, $x = a \pmod {2^k}$, $x = -a \pmod {2^k}$ $x = a + 2^{k-1} \pmod {2^k}$, $x = -a + 2^{k-1} \pmod {2^k}$.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Proves are left to the readers.&lt;/p&gt;
&lt;h5 id=&#34;solving-x2--a2-pmod-pk-where-p-odd-primes&#34;&gt;Solving $x^2 = a^2 \pmod {p^k}$ where $p$ odd primes.&lt;/h5&gt;
&lt;p&gt;Only two solutions exist: $x = a \pmod {p^k}$ and $x = -a \pmod {p^k}$.&lt;/p&gt;
&lt;p&gt;At this point, we already have a way to obtain all $z$ quickly.
Apply PQa with $P_0 = z$, $Q_0 = \frac{N}{f^2}$, $D = D$ until we find the first $(f \times G_i)^2 - (f \times Q_i)^2 = N$ (refer to the paper above for more explanations)&lt;/p&gt;
&lt;p&gt;We also have to find sufficiently many solutions to $x^2 - Dy^2 = 1$ to generate the solutions from the fundamentals above.
With these, the solution to the original equation can be found.&lt;/p&gt;
</description>
		</item>
		<item>
			<title>On Prime Counting in Sublinear Time</title>
			<link>https://prabowo02.github.io/posts/prime-counting/</link>
			<pubDate>Sun, 22 Dec 2019 14:00:39 +0800</pubDate>
			<guid isPermaLink="true">https://prabowo02.github.io/posts/prime-counting/</guid>
			<description>&lt;p&gt;We are to count how many prime numbers are there up to $N$ ($N \leq 10^{11}$).&lt;/p&gt;
&lt;h2 id=&#34;computation&#34;&gt;Computation&lt;/h2&gt;
&lt;p&gt;Let $\pi(N)$ be the number of primes up to $N$, and $f(n, p)$ be the number of integers $x$, for $2 \leq x \leq N$, such that it contains no prime factor $&amp;lt; p$.&lt;/p&gt;
&lt;p&gt;If $p$ is not prime, then $f(n, p) = f(n, p-1)$. Otherwise:&lt;/p&gt;
&lt;p&gt;\begin{align}
f(n, p) = f(n, p-1) - \left(f\Big(\big\lfloor\frac{n}{p} \big\rfloor, p-1\Big) - \pi(p-1)\right)
\tag{1}
\end{align}&lt;/p&gt;
&lt;p&gt;The value $f(\lfloor\frac{n}{p} \rfloor, p-1) - \pi(p-1)$ gives the number of integer $\leq N$ that has $p$ as its prime factor but no prime factor $&amp;lt; p$. In other words, it is subtracting $|\{pk | 1 \leq k \leq n/p, \forall_{\text{prime }q  &amp;lt; p} q \nmid k \}|$ from $f(n, p-1)$.&lt;/p&gt;
&lt;p&gt;Our goal is to compute $\pi(N) = f(N, \sqrt N)$.&lt;/p&gt;
&lt;h3 id=&#34;implementation&#34;&gt;Implementation&lt;/h3&gt;
&lt;p&gt;The idea is similar to the standard prime sieving: eliminate all numbers that is multiple of $2, 3, 5, \ldots, \sqrt N$.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Denote &lt;code&gt;dp[n]&lt;/code&gt; as an array to store the number of primes up to $n$, and initiate the array &lt;code&gt;dp[n]&lt;/code&gt; $= f(n, 1) = n-1$ for all unique values of $\lfloor \frac{N}{i} \rfloor$ (there are $O(\sqrt N) $such values).&lt;/li&gt;
&lt;li&gt;For every prime $p$ in the range $[2, N]$, update &lt;code&gt;dp[n] -= dp[n/p] - dp[p-1]&lt;/code&gt;, for all unique values of $n = \lfloor \frac{N}{i} \rfloor$ and $n \geq p^2$.
&lt;ul&gt;
&lt;li&gt;This is because when iterating prime $p$, all values of &lt;code&gt;dp[n]&lt;/code&gt; is storing $f(n, p-1)$. In particular, for $n &amp;lt; p^2$, it is already storing the number of primes up to &lt;code&gt;n&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Therefore, the operation &lt;code&gt;dp[n] -= dp[n/p] - dp[p-1]&lt;/code&gt; is actually performing the equation from $(1)$.&lt;/li&gt;
&lt;li&gt;By the end of this iteration, &lt;code&gt;dp[n]&lt;/code&gt; will store $f(n, p)$.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Return &lt;code&gt;dp[N]&lt;/code&gt; as our answer.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;pseudo-code&#34;&gt;Pseudo Code&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;primeCounting&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; N) {
  Ni &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sort_descending(unique([N&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;i &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i in [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; .. N]]))
  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (n: Ni) {
    dp[n] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; n&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
  }

  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;; p&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;p &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; N; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;p) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (dp[p] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dp[p&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]) &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// p is not a prime
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (n: Ni) {
      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (n &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;i) &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
      dp[n] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dp[n&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;p] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; dp[p];
    }
  }

  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; dp[N];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;complexity&#34;&gt;Complexity&lt;/h3&gt;
&lt;p&gt;It can be seen that the transition operation of $(1)$ is $O(1)$. Therefore, we just need to compute the space of $f(n, p)$.&lt;/p&gt;
&lt;p&gt;There are two cases:&lt;/p&gt;
&lt;h4 id=&#34;case-1-n-leq-sqrt-n&#34;&gt;Case 1: $n \leq \sqrt N$&lt;/h4&gt;
&lt;p&gt;All values of $n \leq \sqrt N$ exists in the set $\{ \lfloor \frac{N}{i} \rfloor \}$, and for each $n$, only $p^2 \leq n$ will be considered.&lt;/p&gt;
&lt;p&gt;Therefore the overall time complexity for this case:&lt;/p&gt;
&lt;p&gt;$$ \sum_{i=1}^{\sqrt N} \sqrt i = O\left( \int_1^{\sqrt N} \sqrt x \, dx \right) = O(N^{3/4})$$&lt;/p&gt;
&lt;h4 id=&#34;case-2-n--sqrt-n&#34;&gt;Case 2: $n &amp;gt; \sqrt N$&lt;/h4&gt;
&lt;p&gt;The values of $n$ in this case is $\frac{N}{1}, \frac{N}{2}, \ldots, \frac{N}{\sqrt N}$. Since every $n$ needs to consider all $p^2 \leq n$, the time complexity for this case is:&lt;/p&gt;
&lt;p&gt;$$ \sum_{i=1}^{\sqrt N} \sqrt{\frac{N}{i}} = O\left(\sqrt N \int_1^{\sqrt N} \frac{1}{\sqrt x} \, dx \right) = O(N^{3/4})$$&lt;/p&gt;
&lt;h4 id=&#34;total-complexity&#34;&gt;Total Complexity&lt;/h4&gt;
&lt;p&gt;Since the complexity for both cases are the same, the total complexity is $O(N^{3/4})$&lt;/p&gt;
&lt;h2 id=&#34;remarks&#34;&gt;Remarks&lt;/h2&gt;
&lt;h3 id=&#34;speeding-up-computation&#34;&gt;Speeding Up Computation&lt;/h3&gt;
&lt;p&gt;It seems that we can speed up the computation by precomputing the first few prime numbers using the standard sieve of eratosthenes. Precompute the first $f(n, p)$ for $n \leq N^{2/3}$, then for the rest of the $n$, use the same iteration as above. This should run in a little more than $O(N^{2/3})$.&lt;/p&gt;
&lt;h3 id=&#34;other-usages&#34;&gt;Other Usages&lt;/h3&gt;
&lt;p&gt;With a few tweaks, we can compute the following with the same method:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sum of prime up to $n$.&lt;/li&gt;
&lt;li&gt;Sum of prime of the form $4k + 1$ up to $n$.&lt;/li&gt;
&lt;li&gt;Totient summatory function up to $n$.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Looks like it is also possible to further generalize this method using the Dirichlet Hyperbola method.&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Prime-counting_function#The_Meissel%E2%80%93Lehmer_algorithm&#34;&gt;The Meissel-Lehmer algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://math.stackexchange.com/questions/316376/how-to-calculate-these-totient-summation-sums-efficiently&#34;&gt;Efficient Totient Summatory Function&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://math.stackexchange.com/questions/1378286/find-the-sum-of-all-primes-smaller-than-a-big-number&#34;&gt;Sum of primes smaller than a big number&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Dirichlet_hyperbola_method&#34;&gt;Dirichlet Hyperbola Method&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
		</item>
		<item>
			<title>Binomial Modulo Prime Power</title>
			<link>https://prabowo02.github.io/posts/binomial-mod-pe/</link>
			<pubDate>Wed, 04 Dec 2019 16:03:30 +0800</pubDate>
			<guid isPermaLink="true">https://prabowo02.github.io/posts/binomial-mod-pe/</guid>
			<description>&lt;p&gt;This is an attempt to translate &lt;a href=&#34;https://min-25.hatenablog.com/entry/2017/11/01/185400&#34;&gt;min_25&#39;s article&lt;/a&gt; with the help of Google Translate, and with a bit of modification.&lt;/p&gt;
&lt;p&gt;Our goal is to solve ${n \choose m} \pmod{p^e}$, ($n, m, p^e &amp;lt; 10^{300}$, $p$: prime number).&lt;/p&gt;
&lt;p&gt;The method differ from Andrew Granville&#39;s Binomial Coefficients modulo prime powers (&lt;a href=&#34;https://web.archive.org/web/20170202003812/http://www.dms.umontreal.ca/~andrew/PDF/BinCoeff.pdf&#34;&gt;BinCoeff.pdf&lt;/a&gt;).&lt;br&gt;
After precomputation, the number of operation to compute ${n \choose m} \pmod{p^e}$ is reduced from $O\left(e^2\left(\frac{\log n}{\log p} + \min(\log n, \log p)\right)\right)$ to $O(e \log n)$.&lt;/p&gt;
&lt;p&gt;For the rest of the article, denote ${n \brack m}$ as &lt;a href=&#34;https://en.wikipedia.org/wiki/Stirling_numbers_of_the_first_kind&#34;&gt;Stirling number of the first kind&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;computation-method&#34;&gt;Computation Method&lt;/h3&gt;
&lt;p&gt;Define $(n!)_p$ as the product of all positive integers $i \not\equiv 0 \pmod p$ for all $1 \leq i \leq n$. Our goal is to compute $(n!)_p \pmod {p^e}$.&lt;/p&gt;
&lt;p&gt;Let $n = up + v$ where $u, v$ non-negative integers and $0 \leq v &amp;lt; p$.&lt;/p&gt;
&lt;p&gt;For simplicity, we assume that $e &amp;lt; p$,&lt;/p&gt;
&lt;p&gt;$$
\begin{align*}
((up+v)!)_p &amp;amp;= \left( \prod_{i=0}^{u-1} \prod_{j=1}^{p-1} (ip+j) \right) \cdot \prod_{j=1}^v (up + j) \\\&lt;br&gt;
&amp;amp;\equiv \left(\prod_{i=0}^{u-1} \left( \sum_{k=0}^{e-1} (ip)^k {p \brack {k+1}}\right)\right) \cdot \left(\sum_{k=0}^{e-1}(up)^k {{v+1} \brack {k+1}}\right) \pmod {p^e} \\\&lt;br&gt;
&amp;amp;= {p \brack 1}^u \left(\prod_{i=0}^{u-1}\left( 1 + \sum_{k=1}^{e-1} \frac{{p \brack {k+1}}}{{p \brack 1}}(ip)^k \right) \right) \cdot \left( \sum_{k=0}^{e-1} (up)^k {{v+1} \brack {k+1}} \right) \\\&lt;br&gt;
&amp;amp;= {p \brack 1}^u f_{p,e}(u) \left( \sum_{k=0}^{e-1} (up)^k {{v+1} \brack {k+1}} \right)
\end{align*}
$$&lt;/p&gt;
&lt;p&gt;It can be shown that $f_{p, e}$ is a polynomial of degree $(2e - 2)$ (proven below). By calculating the value of $f_{p, e}(0), \ldots, f_{p, e}(2e-2)$, the value of $f_{p, e}(u)$ can be computed in $O(e \log n)$ using &lt;a href=&#34;https://en.wikipedia.org/wiki/Lagrange_polynomial&#34;&gt;Lagrange interpolation&lt;/a&gt; (in $O(e)$ if you precompute the modular inverses).&lt;/p&gt;
&lt;h4 id=&#34;implementation-and-time-complexity&#34;&gt;Implementation and Time Complexity&lt;/h4&gt;
&lt;p&gt;First, compute the &lt;a href=&#34;https://en.wikipedia.org/wiki/P-adic_order&#34;&gt;$p$-adic valuation&lt;/a&gt; of ${n \choose m}$. If it is not less than $e$, then the modulo is 0. Otherwise, we factor out all the $p$ factors in $n!, m!, (n-m)!$ then we compute the factorials, and multiply with the $p$ factors at the end of the ${n \choose m}$ computation below.&lt;/p&gt;
&lt;p&gt;After the 0 case handling, we do the steps as follow:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;${n \brack m} (1 \leq n \leq p, 1 \leq m \leq \min(p, e))$ is precomputed in $O(p \cdot \min(p, e))$&lt;/li&gt;
&lt;li&gt;$f_{p, e}(0), \ldots, f_{p, e}(2e-2)$ for interpolation are precomputed in $O(e \cdot \min(p, e) + e \log p)$&lt;/li&gt;
&lt;li&gt;Computation of $n!$ without the factor $p$ can be done by $\sum_{k=0}^\infty \left(\left\lfloor\frac{n}{p^k}\right\rfloor_p\right)!$ in $O(e \log n)$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In total, there are around $O(pe + e^2 + e \log n)$ time complexity to compute ${n \choose m}$&lt;/p&gt;
&lt;h4 id=&#34;proof-that-fp-e-is-a-polynomial&#34;&gt;Proof that $f_{p, e}$ is a polynomial&lt;/h4&gt;
&lt;p&gt;For any $e, p$ $(e \geq 1, p \geq 2)$, let $a_k$ be a rational number that exists under modulo $p$. Let,&lt;/p&gt;
&lt;p&gt;$$ g(x, u) := \prod_{i=0}^{u-1} \left( 1 + \sum_{k=1}^{e-1} a_k (xi)^k \right) $$&lt;/p&gt;
&lt;p&gt;Let $b_k$ be some other rational number satisfying:&lt;/p&gt;
&lt;p&gt;$$
\begin{align*}
\log(g(x, u)) &amp;amp;= \sum_{i=0}^{u-1} \log\left( 1 + \sum_{k=1}^{e-1} a_k(xi)^k \right) \\\&lt;br&gt;
&amp;amp;= \sum_{i=0}^{u-1} \sum_{k=0}^\infty b_k x^k i^k \\\&lt;br&gt;
&amp;amp;= \sum_{k=1}^\infty b_k x^k s_k(u)
\end{align*}
$$&lt;/p&gt;
&lt;p&gt;where $s_k(x) = \sum_{i=0}^x i^k$ is a polynomial of degree $k+1$. Continuing from above,&lt;/p&gt;
&lt;p&gt;$$
\begin{align*}
g(x, u) &amp;amp;= \exp\left( \sum_{k=1}^\infty b_k x^k s_k(u) \right) \\\&lt;br&gt;
&amp;amp;= 1 + \sum_{k=1}^\infty t_k(u) x^k
\end{align*}
$$&lt;/p&gt;
&lt;p&gt;where $t_k(u)$ is a polynomial of degree $2k$, because the highest polynomial degree obtained at $x^k$ is from $(b_1 x s_1(u))^k$. The coefficients of $t_k(u)$ are also rational number which exists under modulo $p$.&lt;/p&gt;
&lt;p&gt;Substituting $x = p$ gives us the polynomial of $f_{p, e}(u)$:&lt;/p&gt;
&lt;p&gt;$$ g(p, u) \equiv 1 + \sum_{k=1}^{e-1} t_k(u) \cdot p^k \pmod{p^e} $$&lt;/p&gt;
&lt;p&gt;Therefore, $f_{p, e}(x)$ is a polynomial of degree $(2e - 2)$.&lt;/p&gt;
&lt;h3 id=&#34;remark&#34;&gt;Remark&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;If $p$ is prime, ${p \brack i}$ $(2 \leq i &amp;lt; p)$ is divisible by $p$.&lt;/li&gt;
&lt;li&gt;If $p \geq 5$, ${p \brack 2}$ is divisible by $p^2$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Using these properties, looks like it is possible to further reduce the degree of $f_{p, e}(x)$.&lt;/p&gt;
&lt;h3 id=&#34;source-codes&#34;&gt;Source Codes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;min_25&#39;s implementation using &lt;a href=&#34;https://gist.github.com/min-25/a5496354e10064a581d6b0c52c727a26&#34;&gt;Python&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;My implementation using &lt;a href=&#34;https://github.com/prabowo02/CP/blob/master/binomial_mod_pe.cpp&#34;&gt;C++&lt;/a&gt; (but it is not using big integer, only &lt;code&gt;__int128&lt;/code&gt;, so it can only support for $n$ up to $10^{18}$).&lt;/li&gt;
&lt;/ul&gt;
</description>
		</item>
		<item>
			<title>Project Euler #242</title>
			<link>https://prabowo02.github.io/posts/project-euler-242/</link>
			<pubDate>Fri, 29 Nov 2019 12:15:14 +0800</pubDate>
			<guid isPermaLink="true">https://prabowo02.github.io/posts/project-euler-242/</guid>
			<description>&lt;p&gt;This post will give the analysis to &lt;a href=&#34;https://www.hackerrank.com/contests/projecteuler/challenges/euler242/problem&#34;&gt;Project Euler #242&lt;/a&gt; from hackerrank, which is an extended version from the &lt;a href=&#34;https://projecteuler.net/problem=242&#34;&gt;original&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;problem-statement&#34;&gt;Problem Statement&lt;/h3&gt;
&lt;p&gt;Given 5 integers $m$, $r$, $n$, $k$, and $M$, count the number of k-subsets of $\{1, 2, \ldots, n\}$ such that the sum of the subset is $r \pmod m$. Let the answer be $S$, output $S \times m$ modulo $M$.&lt;/p&gt;
&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;$2 \leq m \leq 10^{11}$&lt;/li&gt;
&lt;li&gt;$0 \leq r \leq m$&lt;/li&gt;
&lt;li&gt;$1 \leq k \leq n \leq 10^{18}$&lt;/li&gt;
&lt;li&gt;For each positive divisor $d$ of $m$: $n \mod d \leq k \mod d$&lt;/li&gt;
&lt;li&gt;$2 \leq M \leq 2^{62}$&lt;/li&gt;
&lt;li&gt;The largest prime factor of $M$ is less than $10^5$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;
&lt;p&gt;This is actually an extended version of &lt;a href=&#34;https://www.imo-official.org/year_info.aspx?year=1995&#34;&gt;IMO 1995 P6&lt;/a&gt; (having $m = p$, $n = 2p$, $k = p$, $r = 0$). A discussion to this problem can be found in &lt;a href=&#34;https://artofproblemsolving.com/community/c6h15112p107230&#34;&gt;AOPS&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Back to the original problem, consider the generating function $(1 + xy)(1 + xy^2) \ldots (1 + xy^n)$. Our answer will be the sum of coefficients of $x^k y^r, x^k y^{r+m}, x^k y^{r+2m}, \ldots$.&lt;/p&gt;
&lt;p&gt;To get this sum, we use the &lt;a href=&#34;https://en.wikipedia.org/wiki/Series_multisection&#34;&gt;Series Multisection&lt;/a&gt; formula on the y coefficients, then our generating function become:&lt;/p&gt;
&lt;p&gt;$$\frac{1}{m} \sum_{l=0}^{m-1} \left( \omega^{-lr} \prod_{i=1}^n (1 + x\omega^{li}) \right)$$&lt;/p&gt;
&lt;p&gt;where $\omega$ is the primitive $m$-th root of unity. Since the final answer will be multiplied by $m$, the $\frac{1}{m}$ will be ignored for the rest of this post. Now our goal is to find the coefficient of $x^k$ from that equation.&lt;/p&gt;
&lt;p&gt;Using the &lt;a href=&#34;http://mathworld.wolfram.com/CauchyBinomialTheorem.html&#34;&gt;Cauchy Binomial Theorem&lt;/a&gt;, we convert our equation above to:&lt;/p&gt;
&lt;p&gt;$$\sum_{l=0}^{m-1} \left( \omega^{-lr} \sum_{i=0}^n x^i \omega^{li(i+1)/2} {n \brack i}_{\omega^l} \right)$$&lt;/p&gt;
&lt;p&gt;Since we only care with the $x^k$ coefficient, then the answer to our original problem is the evaluation of:&lt;/p&gt;
&lt;p&gt;$$ \sum_{i=0}^{m-1} \left( (\omega^{i})^{k(k+1)/2 - r} {n \brack k}_{\omega^i} \right) $$&lt;/p&gt;
&lt;p&gt;We will compute the sum for each primitive of $\omega^i$ separately. Denote $\omega_d$ as the primitive $d$-th root of unity. Also note the &lt;a href=&#34;https://www.math.upenn.edu/~peal/polynomials/q-analogues.htm#prelimQanaloguesQLucas&#34;&gt;q-Lucas theorem&lt;/a&gt;: ${n \brack k}_{\omega_d} = {\lfloor n/d \rfloor \choose \lfloor k/d \rfloor } {n \mod d \brack k \mod d}_{\omega_d}$.&lt;br&gt;
Since $n \mod d \leq k \mod d$, the value of ${n \mod d \brack k \mod d} = 1$ if $n \equiv k \pmod d$, $0$ otherwise.&lt;br&gt;
With these in mind, we rewrite our equation to:&lt;/p&gt;
&lt;p&gt;$$ \sum_{d|m} \left( \sum_{(d, i) = 1}^d (\omega_d^i)^{k(k+1)/2 - r}  {n \choose k}[n \equiv k \pmod d] \right) $$&lt;/p&gt;
&lt;p&gt;where $[]$ is the &lt;a href=&#34;https://en.wikipedia.org/wiki/Iverson_bracket&#34;&gt;Iverson bracket&lt;/a&gt;. Recall that the sum of $k$-th power of the $d$-th root of unity is $\frac{\mu(d / \gcd(k, d)) \varphi(d)}{\varphi(d / \gcd(k, d))}$, where $\mu$ is the &lt;a href=&#34;https://en.wikipedia.org/wiki/M%C3%B6bius_function&#34;&gt;Möbius function&lt;/a&gt; and $\varphi$ is the &lt;a href=&#34;https://en.wikipedia.org/wiki/Euler%27s_totient_function&#34;&gt;Euler&#39;s Totient function&lt;/a&gt;.&lt;br&gt;
Therefore, our final answer is:&lt;/p&gt;
&lt;p&gt;$$ \sum_{d|m} \left( \frac{\mu\left(\frac{d}{\gcd(k(k+1)/2 - r, d)}\right) \varphi(d)}{\varphi\left(\frac{d}{\gcd(k(k+1)/2 - r, d)}\right)} {n \choose k}[n \equiv k \pmod d] \right) $$&lt;/p&gt;
&lt;p&gt;And now, for the computational part. Compute the final sum for every prime factor of $M$, then combine the answers using &lt;a href=&#34;https://en.wikipedia.org/wiki/Chinese_remainder_theorem&#34;&gt;Chinese Remainder Theorem&lt;/a&gt;. The computation of binomial theorem modulo $p^e$ can be computed in $O(e(p + e + \log n))$, which is described in this &lt;a href=&#34;https://prabowo02.github.io/posts/binomial-mod-pe&#34;&gt;post&lt;/a&gt;.&lt;br&gt;
The computation of the divisors of $m$ and all its mobius and euler totient values can be computed in $O(\sqrt m)$&lt;/p&gt;
&lt;p&gt;Therefore, the overall complexity is $O(\sqrt m + \log M \log n)$.&lt;/p&gt;
</description>
		</item>
	</channel>
</rss>
