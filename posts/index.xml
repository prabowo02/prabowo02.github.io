<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on Notes</title>
		<link>https://prabowo02.github.io/posts/</link>
		<description>Recent content in Posts on Notes</description>
		<generator>Hugo 0.115.3 -- gohugo.io</generator>
		<language>en-us</language>
		<lastBuildDate>Sun, 16 Jul 2023 21:22:18 +0800</lastBuildDate>
		<atom:link href="https://prabowo02.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		<item>
			<title>How to incorrectly use Generating Function</title>
			<link>https://prabowo02.github.io/posts/not-gf/</link>
			<pubDate>Sun, 16 Jul 2023 21:22:18 +0800</pubDate>
			<guid isPermaLink="true">https://prabowo02.github.io/posts/not-gf/</guid>
			<description>&lt;p&gt;Generating functions can be used to &lt;em&gt;cheese&lt;/em&gt; numerous counting problems without too much thinking.
Here, I will show the &lt;strong&gt;not&lt;/strong&gt; proper way to use generating function to solve such problems.&lt;/p&gt;
&lt;p&gt;A few people may find the generating function approach for some of these problems is more &amp;ldquo;intuitive&amp;rdquo;, as the combinatorial approach is a bit out of the blue.&lt;/p&gt;
&lt;h2 id=&#34;codeforces-1549-e----the-three-little-pigshttpscodeforcescomcontest1549probleme&#34;&gt;&lt;a href=&#34;https://codeforces.com/contest/1549/problem/E&#34;&gt;Codeforces 1549 E &amp;ndash; The Three Little Pigs&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Given $N$, then given $Q$ queries, each gives you an integer $K$ and asks you to compute $\sum_{i=0}^N \binom{3i}{K}$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$N \le 1\,000\,000$&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;proper-solution&#34;&gt;Proper solution&lt;/h3&gt;
&lt;p&gt;Let $\text{dp}_0(K)$, $\text{dp}_1(K)$, and $\text{dp}_2(K)$ be the sum $\sum_{i=0}^N \binom{3i}{K}$, $\sum_{i=0}^N \binom{3i + 1}{K}$, and $\sum_{i=0}^N \binom{3i + 2}{K}$ respectively.&lt;/p&gt;
&lt;p&gt;We can see that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\text{dp}_0(K) + \text{dp}_1(K) + \text{dp}_2(K) = \sum_{i=0}^{3N+2} \binom{i}{K} = \binom{3N + 3}{K + 1}$ using the Hockey-stick identity;&lt;/li&gt;
&lt;li&gt;$\text{dp}_1(K) = \text{dp}_0(K) + \text{dp}_0(K - 1)$ using the Pascal&amp;rsquo;s rule; and&lt;/li&gt;
&lt;li&gt;$\text{dp}_2(K) = \text{dp}_1(K) + \text{dp}_1(K - 1)$ using the Pascal&amp;rsquo;s rule.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With three equations and three unknowns, the values of all DP can then be inferred.&lt;/p&gt;
&lt;h3 id=&#34;generating-function-approach&#34;&gt;Generating function approach&lt;/h3&gt;
&lt;p&gt;Suppose we are able to evaluate $\sum_{i=0}^N (1 + x)^{3i}$, then for each query, the answer is the $K$-th coefficient of that generating function.&lt;/p&gt;
&lt;p&gt;To evaluate that polynomial,&lt;/p&gt;
&lt;p&gt;$$
\begin{align*}
\sum_{i=0}^N (1 + x)^{3i} &amp;amp;= \frac{1 - (1 + x)^{3N + 3}}{1 - (1 + x)^3} \\
&amp;amp;= \frac{\sum_{i=1}^{3N + 3} \left(\binom{3N + 3}{i} x^i\right)}{-3x -3x^2 - x^3}
\end{align*}
$$&lt;/p&gt;
&lt;p&gt;The binomial coefficients from the numerator can be easily computed, then perform a standard long division to get the final G.F. in $\mathcal{O}(N)$.&lt;/p&gt;
&lt;h2 id=&#34;atcoder-regular-contest-110-d----binomial-coefficient-is-funhttpsatcoderjpcontestsarc110tasksarc110_d&#34;&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc110/tasks/arc110_d&#34;&gt;AtCoder Regular Contest 110 D &amp;ndash; Binomial Coefficient is Fun&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Given a sequence $A$ of $N$ integers, compute the sum $\prod_{i=1}^N \binom{B_i}{A_i}$ over all sequences $B$ of $N$ non-negative integers whose sum is at most $M$.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$1 \le N \le 2000$&lt;/li&gt;
&lt;li&gt;$1 \le M \le 10^9$&lt;/li&gt;
&lt;li&gt;$0 \le A_i \le 2000$&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;proper-solution-1&#34;&gt;Proper solution&lt;/h3&gt;
&lt;p&gt;Suppose you have $\sum A_i + N$ bars and $M - \sum A_i$ stars.
The stars and bars before the $a_1$-th bar correspond to $\binom{B_1}{A_1}$; the stars and bars strictly between the $a_1$-th and $a_1 + a_2$-th bars correspond to $\binom{B_2}{A_2}$; and so on; and the stars after the $\sum A_i$-th bar are those that does not make the $B$ sum up to $M$.&lt;/p&gt;
&lt;p&gt;The number of ways to arrange those stars and bars is then $\binom{M + N}{\sum A_i + N}$.&lt;/p&gt;
&lt;h3 id=&#34;generating-function-approach-1&#34;&gt;Generating function approach&lt;/h3&gt;
&lt;p&gt;Recall that $[x^n] \frac{x^k}{(1 - x)^{k - 1}} = \binom{n}{k}$.&lt;/p&gt;
&lt;p&gt;That means the sum of products from the description such that $B$ has a sum of exactly $m$ is the $m$-th coefficient of:&lt;/p&gt;
&lt;p&gt;$$\prod_{i = 1}^N \frac{x^{A_i}}{(1 - x)^{A_i - 1}} = \frac{x^{\sum A_i}}{(1 - x)^{\sum A_i - N}}$$&lt;/p&gt;
&lt;p&gt;And to get the sum for all coefficients of $x^m$ with $m \le M$, we can get the &amp;ldquo;prefix-sum&amp;rdquo; of the above G.F. (by multiplying it with $(1 - x)^{-1}$, and simply get the $M$-th coefficient. In short,&lt;/p&gt;
&lt;p&gt;$$[x^M] \frac{x^{\sum A_i}}{(1 - x)^{\sum A_i - N + 1}}$$&lt;/p&gt;
&lt;p&gt;which conveniently equals to $\binom{M + N}{\sum A_i + N}$.&lt;/p&gt;
&lt;h2 id=&#34;ioi-2022-circuithttpsioinformaticsorgfilesioi2022problem4pdf&#34;&gt;&lt;a href=&#34;https://ioinformatics.org/files/ioi2022problem4.pdf&#34;&gt;IOI 2022 Circuit&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Given a rooted tree of $N$ nodes, its leaves has initial state of $0$ or $1$. You can assign an integer parameter $p$ for each internal node (and $p$ is at most the number of its children), then its state will be $1$ if at least $p$ of its children have state $1$. Given $Q$ updates which toggle the state of the leaf nodes from $L$ to $R$, find the number of ways to assign those parameters such that the root node has a state of $1$.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;proper-solution-2&#34;&gt;Proper solution&lt;/h3&gt;
&lt;p&gt;The assignment of a parameter to a node can be reinterpreted as an operator that takes a value from one of its children.
Hence, for each leaf with state $1$, we count how many ways are there to have its value reaching the root, which equals the product of all internal nodes&amp;rsquo;, excluding the nodes that are in the path between the leaf to the root, number of children.&lt;/p&gt;
&lt;h3 id=&#34;generating-function-approach-2&#34;&gt;Generating function approach&lt;/h3&gt;
&lt;p&gt;Denote $\text{dp}_0(v)$ and $\text{dp}_1(v)$ as the number of ways to assign parameters for all subtree of $v$ such that the state of $v$ is $0$ and $1$ respectively.&lt;/p&gt;
&lt;p&gt;Suppose $v_1, \ldots, v_c$ is the children of $v$, then the number of ways such that exactly $k$ children of $v$ has state of $1$ is the $k$-th coefficient of:&lt;/p&gt;
&lt;p&gt;$$\prod_{i=1}^c (\text{dp}_0(v_i) + x \text{dp}_1(v_i))$$&lt;/p&gt;
&lt;p&gt;That means the number of ways to get state $1$ if we assign parameter $p$ to node $v$, is the sum of $k$-th ($k \ge p$) coefficient of the above G.F..
Summing for all possible $p$, we can see that we actually need the value $k$ times the $k$-th coefficient.
So we can transform the generating function by doing its derivative:&lt;/p&gt;
&lt;p&gt;$$
\begin{align*}
&amp;amp;x \frac{\mathrm{d}}{\mathrm{d}x} \prod_{i=1}^c (\text{dp}_0(v_i) + x \text{dp}_1(v_i)) \\
=&amp;amp;x \frac{\mathrm{d}}{\mathrm{d}x} \exp \log \prod_{i=1}^c (\text{dp}_0(v_i) + x \text{dp}_1(v_i)) \\
=&amp;amp;x \frac{\mathrm{d}}{\mathrm{d}x} \exp \sum_{i=1}^c \log (\text{dp}_0(v_i) + x \text{dp}_1(v_i)) \\
=&amp;amp;\sum_{i=1}^c \frac{x \text{dp}_1(v_i)}{(\text{dp}_0(v_i) + x \text{dp}_1(v_i))} \exp \sum_{i=1}^c \log (\text{dp}_0(v_i) + x \text{dp}_1(v_i)) \\
=&amp;amp;\sum_{i=1}^c \frac{x \text{dp}_1(v_i)}{(\text{dp}_0(v_i) + x \text{dp}_1(v_i))} \prod_{i=1}^c(\text{dp}_0(v_i) + x \text{dp}_1(v_i)) \\
\end{align*}
$$&lt;/p&gt;
&lt;p&gt;And because we only need the sum of all those coefficients, we substitute $x = 1$, then obtain the final formula of the DP as:&lt;/p&gt;
&lt;p&gt;$$\text{dp}_1(v) = \sum_{i=1}^c \frac{\text{dp}_1(v_i)}{(\text{dp}_0(v_i) + \text{dp}_1(v_i))} \prod_{i=1}^c(\text{dp}_0(v_i) + \text{dp}_1(v_i))$$&lt;/p&gt;
&lt;p&gt;Now see that $\text{dp}_0(v) + \text{dp}_1(v)$ is equal to $\prod_{u \in \text{subtree}(v)} \deg(u)$ (where $\deg(u)$ is the number of children of $u$, except when $u$ is a leaf which we set to be $1$ for convenience) because we can assign any parameter to the nodes in the subtree of $v$ without any restriction to the end state of $v$. We denote this value as $p(v)$ which can be precomputed and stays constant throughout the whole update.&lt;/p&gt;
&lt;p&gt;Rewrite our DP formula:&lt;/p&gt;
&lt;p&gt;$$
\begin{align*}
\text{dp}_1(v) &amp;amp;= \sum_{i=1}^c \frac{\text{dp}_1(v_i)}{p(v_i)} \prod_{i=1}^c p(v_i) \\
&amp;amp;= \sum_{i=1}^c \left(\frac{p(v)}{\deg(v) p(v_i)} \text{dp}_1(v_i)\right)
\end{align*}
$$&lt;/p&gt;
&lt;p&gt;Now, here comes the &amp;ldquo;Competitive Programming&amp;rdquo; part. Imagine you recurse the above formula up to the leaves.
Then, suppose $[u_0, u_1, \ldots, u_k]$ is the path from the root node $u_0$ to a leaf node $u_k$, compute $\prod_{i=1}^k \frac{p(u_{i-1})}{\deg(u_{i-1}) p(u_i)}$, and assign this value to the leaf node $u_k$. If the source gate $u_k$ is $1$, then the assigned value will contribute to the sum of the final answer. Otherwise, its contribution is $0$.&lt;/p&gt;
</description>
		</item>
		<item>
			<title>On counting the number of zigzag sequences</title>
			<link>https://prabowo02.github.io/posts/zigzag-sequences/</link>
			<pubDate>Sun, 10 Jul 2022 18:30:00 +0800</pubDate>
			<guid isPermaLink="true">https://prabowo02.github.io/posts/zigzag-sequences/</guid>
			<description>&lt;p&gt;I feel like these are classical, but it&amp;rsquo;s hard to find a good discussion about them, so here we go.&lt;/p&gt;
&lt;p&gt;We will discuss two things here:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;find the number of zigzag permutations, and&lt;/li&gt;
&lt;li&gt;find the number of zigzag sequences.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;counting-zigzag-permutations&#34;&gt;Counting Zigzag permutations&lt;/h2&gt;
&lt;p&gt;Given $N \le 200\;000$, find the number of permutations that satisfy $p_1 \lt p_2 \gt p_3 \lt p_4 \gt \ldots p_N$.&lt;/p&gt;
&lt;p&gt;You may stop here if you are interested to solve the problem by yourself first.&lt;/p&gt;
&lt;h3 id=&#34;terminologies&#34;&gt;Terminologies&lt;/h3&gt;
&lt;p&gt;First, let us clear up the terminology we are going to use.&lt;/p&gt;
&lt;p&gt;A &lt;em&gt;permutation&lt;/em&gt; of length $N$ is a sequence of length $N$ where $1, 2, \ldots, N$ each appears exactly once.
In this article, whenever I omit the &amp;ldquo;of length $N$&amp;rdquo;, the permutation always has length $N$ by default.&lt;/p&gt;
&lt;p&gt;A &lt;em&gt;zigzag permutation&lt;/em&gt; is a permutation $p$, such that $p_1 \lt p_2 \gt p_3 \lt p_4 \gt \ldots p_n$.
More formally, the relation $p_i \lt p_{i+1}$ is satisfied when $i$ is odd, and $p_i \gt p_{i+1}$ when $i$ is even.&lt;/p&gt;
&lt;p&gt;We define similarly a &lt;em&gt;zagzig permutation&lt;/em&gt; as a permutation $p$, such that $p_1 \gt p_2 \lt p_3 \gt p_4 \gt \ldots p_n$.
This is the same as zigzag permutation, as they both have alternating relations, but this one starts with $\gt$.&lt;/p&gt;
&lt;p&gt;We will also collectively refer both &lt;em&gt;zigzag&lt;/em&gt; and &lt;em&gt;zagzig&lt;/em&gt; permutations as &lt;em&gt;alternating permutations&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;catalan-like-dp&#34;&gt;Catalan-like DP&lt;/h3&gt;
&lt;p&gt;Before getting to the calculation, we first note that there exists a bijection between zigzag permutations and zagzig permutations.
This is easy to show: for a zigzag permutation $p$, we map $p_i$ to $N - p_i + 1$.&lt;/p&gt;
&lt;p&gt;Moreover, for $N \ge 2$ the set of zigzag permutations are mutually exclusive from the set of zagzig permutations.
This means that, if we know the cardinality of a set of alternating permutations (of length $N \ge 2$), then the cardinality of the zigzag permutations is exactly half of it.&lt;/p&gt;
&lt;p&gt;Let $a_n$ be the number of zigzag permutations of length $n$.
That is, the number of alternating permutations is $2a_n$ for $n \ge 2$.&lt;/p&gt;
&lt;p&gt;The key to compute $a_n$ is we consider every position of its largest element $n$, then we &amp;ldquo;attach&amp;rdquo; a reversed zigzag permutation to the left, then attach another zigzag permutation to the right of the largest element. Note that this will give you all the alternating permutations instead of the zigzag permutations alone. The elements that are to the left of the largest can be chosen from any of the remaining $n - 1$ elements.&lt;/p&gt;
&lt;p&gt;To sum up:&lt;/p&gt;
&lt;p&gt;$$2a_n = \sum_{k=0}^{n-1} \binom{n - 1}{k} a_k a_{n-1-k}$$&lt;/p&gt;
&lt;p&gt;or to make it prettier:&lt;/p&gt;
&lt;p&gt;$$2a_{n+1} = \sum_{k=0}^{n} \binom{n}{k} a_k a_{n-k}$$&lt;/p&gt;
&lt;p&gt;for $n \ge 1$ with the base case $a_0 = a_1 = 1$.&lt;/p&gt;
&lt;p&gt;This can be easily computed using DP in $O(N^2)$.&lt;/p&gt;
&lt;h3 id=&#34;faster-computation&#34;&gt;Faster Computation&lt;/h3&gt;
&lt;p&gt;Let $A(x)$ be the exponential generating function of the sequence $(a)_n$. That is,&lt;/p&gt;
&lt;p&gt;$$A(x) = \sum_{k=0}^\infty \frac{a_k}{k!} x^k$$&lt;/p&gt;
&lt;p&gt;Then,&lt;/p&gt;
&lt;p&gt;$$2A(x) = \int A(x)^2 dx + x + 2$$&lt;/p&gt;
&lt;p&gt;The purpose of the integration is to &amp;ldquo;shift&amp;rdquo; the EGF by one, and the $x + 2$ part is to make the base case of $[x^0]$ and $[x^1]$ be both $2$ (recall that we are computing $2A(x)$, not a single $A(x)$).&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s solve the integration formula. We derive both sides:&lt;/p&gt;
&lt;p&gt;$$2 \frac{\mathrm{d}}{\mathrm{d}x} A(x) = A(x)^2 + 1$$&lt;/p&gt;
&lt;p&gt;Since I have nothing better to do, I will derive this ordinary differential equation in more details.
We divide both sides by $A(x)^2 + 1$ then integrate both sides.&lt;/p&gt;
&lt;p&gt;$$\int \frac{2}{A(x)^2 + 1} \mathrm{d}A(x) = \int dx$$&lt;/p&gt;
&lt;p&gt;Use the trigonometry substituion $A(x) = \tan(t)$ and we obtain:&lt;/p&gt;
&lt;p&gt;$$\int \frac{2}{\tan(t)^2 + 1} \sec(t)^2 dt = x + C$$&lt;/p&gt;
&lt;p&gt;Note the trigonometry identity $\tan(t)^2 + 1 = \sec(t)^2$, then:&lt;/p&gt;
&lt;p&gt;$$2\arctan(A(x)) = x + C$$&lt;/p&gt;
&lt;p&gt;We note that when $x = 0$, $A(0) = 1$, hence:&lt;/p&gt;
&lt;p&gt;$$A(x) = \tan\left(\frac{x}{2} + \frac{\pi}{4}\right)$$&lt;/p&gt;
&lt;p&gt;Use the tangent half-angle formula, and we finally obtain:&lt;/p&gt;
&lt;p&gt;$$A(x) = \sec(x) + \tan(x) = \frac{1 + \sin(x)}{\cos(x)}$$&lt;/p&gt;
&lt;p&gt;and this can be easily calculated in $O(N \log N)$ using FFT.&lt;/p&gt;
&lt;p&gt;Apparently, the resulting generating function is also known as André&amp;rsquo;s theorem.&lt;/p&gt;
&lt;h2 id=&#34;counting-zigzag-sequences&#34;&gt;Counting Zigzag Sequences&lt;/h2&gt;
&lt;p&gt;Given $N \le 200\;000$ and $M \le 10^9$, find the number of sequences of positive integers such that $a_i \le M$ and $a_1 \lt a_2 \gt a_3 \lt a_4 \gt \ldots a_N$.&lt;/p&gt;
&lt;p&gt;To solve this problem, we must first forget everything from the previous section as they prove to be useless for this problem.&lt;/p&gt;
&lt;p&gt;The key idea here is inclusion-exclusion, and we have to solve by cases.&lt;/p&gt;
&lt;h3 id=&#34;n-is-even&#34;&gt;N is even&lt;/h3&gt;
&lt;p&gt;We will apply inclusion-exclusion on the &amp;ldquo;$\gt$&amp;rdquo; part.
What this means is we keep all the &amp;ldquo;$\lt$&amp;rdquo; signs, ignore some of the &amp;ldquo;$\gt$&amp;rdquo; conditions, and replace all the other &amp;ldquo;$\gt$&amp;rdquo; with &amp;ldquo;$\le$&amp;rdquo;.
For every such replacement, count the number of the inequalities, then multiply by $(-1)^{\text{\# of ≤}}$, then sum for all of the possible replacements.&lt;/p&gt;
&lt;p&gt;The sum is not straightforward to come. Instead, for one possible replacement, we will consider a &lt;em&gt;chain&lt;/em&gt; as the maximal subsegment such that $a_{2i+1} \lt a_{2i+2} \le a_{2i+3} \lt \ldots \le a_{2j}$. That is, the chain is a maximal consecutive subsequence such that it contains either &amp;ldquo;$\lt$&amp;rdquo; or &amp;ldquo;$\le$&amp;rdquo;. Notice that such a chain always has an even length.&lt;/p&gt;
&lt;p&gt;The number of sequences $b$ of length $2n$ (an even number) such that $b_1 \lt b_2 \le b_3 \lt \ldots \le b_{2n}$ can be easily found out as $\binom{M + n - 1}{2n}$.&lt;/p&gt;
&lt;p&gt;Now, we just have to &amp;ldquo;glue&amp;rdquo; up all these chains to form a sequence of length $N$.&lt;/p&gt;
&lt;p&gt;So we obtain this DP formula:&lt;/p&gt;
&lt;p&gt;$$dp(n) = \sum_{k=1}^n (-1)^{k-1} \binom{M+k-1}{2k} dp(n-k)$$&lt;/p&gt;
&lt;p&gt;and our answer is $dp(\frac{N}{2})$ which can be solved in $O(N^2)$.&lt;/p&gt;
&lt;p&gt;To speed it up, define $P(x)$ as the generating function:&lt;/p&gt;
&lt;p&gt;$$P(x) = \sum_{k=1}^\infty (-1)^{k-1} \binom{M+k-1}{2k} x^{2k}$$.&lt;/p&gt;
&lt;p&gt;then we simply need to find:&lt;/p&gt;
&lt;p&gt;$$[x^N](1 + P(x) + P(x)^2 + \ldots) = [x^N]\frac{1}{1 - P(x)}$$&lt;/p&gt;
&lt;p&gt;using FFT in $O(N \log N)$.&lt;/p&gt;
&lt;h3 id=&#34;n-is-odd&#34;&gt;N is odd&lt;/h3&gt;
&lt;p&gt;We continue from the result of the even case. What we need to do now is to add a single odd chain at the end.&lt;/p&gt;
&lt;p&gt;So we define the generating function of the odd chain:&lt;/p&gt;
&lt;p&gt;$$Q(x) = \sum_{k=0}^\infty (-1)^k \binom{M+k}{2k+1} x^{2k+1}$$&lt;/p&gt;
&lt;p&gt;Then we can simply find&lt;/p&gt;
&lt;p&gt;$$[x^N] \frac{Q(x)}{1 - P(x)}$$&lt;/p&gt;
&lt;p&gt;with FFT in $O(N \log N)$.&lt;/p&gt;
&lt;h3 id=&#34;combining-both-cases&#34;&gt;Combining both cases&lt;/h3&gt;
&lt;p&gt;Since both GFs are &amp;ldquo;independent&amp;rdquo;, we can simply find:&lt;/p&gt;
&lt;p&gt;$$[x^N] \frac{1 + Q(x)}{1 - P(x)}$$&lt;/p&gt;
&lt;p&gt;without the need for a parity check of $N$.&lt;/p&gt;
</description>
		</item>
		<item>
			<title>Sum of $C(N, i) \times i^K$</title>
			<link>https://prabowo02.github.io/posts/sum-cnk-xk/</link>
			<pubDate>Tue, 01 Jun 2021 23:08:09 +0800</pubDate>
			<guid isPermaLink="true">https://prabowo02.github.io/posts/sum-cnk-xk/</guid>
			<description>&lt;p&gt;Have you ever felt the need to compute:&lt;/p&gt;
&lt;p&gt;$$\sum_{i=0}^N \binom{N}{i} i^K $$&lt;/p&gt;
&lt;p&gt;where $N \le 10^9$ and $K \le 10^5$? Well you are in luck, because I&amp;rsquo;m about to show you how.&lt;/p&gt;
&lt;p&gt;Consider the binomial expansion:&lt;/p&gt;
&lt;p&gt;$$f_0(x) := (1 + x)^N = \sum_{i=0}^N \binom{N}{i} x^i$$&lt;/p&gt;
&lt;p&gt;If you differentiate then multiply by $x$, you will get:&lt;/p&gt;
&lt;p&gt;$$f_1(x) := x \frac{\mathrm{d}}{\mathrm{d}x}(1 + x)^N = \sum_{i=0}^N \binom{N}{i}\cdot i \cdot x^i$$&lt;/p&gt;
&lt;p&gt;Then repeatedly differentiate and multiply by $x$ (i.e. $f_k(x) = x \frac{\mathrm{d}}{\mathrm{d}x} f_{k - 1}(x)$), then you will end up with:&lt;/p&gt;
&lt;p&gt;$$f_K(x) = \sum_{i=0}^N \binom{N}{i} i^K x^i$$&lt;/p&gt;
&lt;p&gt;Evaluate $f_K(1)$ then you will get the answer to the original question.&lt;/p&gt;
&lt;p&gt;The value of $f_K$ is actually:&lt;/p&gt;
&lt;p&gt;$$f_K(x) = \sum_{i=0}^K S(K, i) \cdot (N)_i \cdot (1 + x)^{N-i}$$&lt;/p&gt;
&lt;p&gt;where $S$ is the Stirling number of the second kind and $(N)_i$ is the falling factorial $N(N - 1) \ldots (N - i + 1)$.
The formula can be easily shown using induction following the property $S(N, K) = K \cdot S(N - 1, K) + S(N - 1, K - 1)$.&lt;/p&gt;
&lt;p&gt;The computation of $(N)_i$ for all $0 \le i \le K$ can be easily computed in $O(K)$, and the computation of $S(K, i)$ can be done using FFT (&lt;a href=&#34;https://en.wikipedia.org/wiki/Touchard_polynomials&#34;&gt;Touchard Polynomial&lt;/a&gt;) in $O(K \log K)$.&lt;/p&gt;
&lt;p&gt;In case you need something more general:&lt;/p&gt;
&lt;p&gt;$$\sum_{i=0}^N \binom{N}{i} \cdot i^K \cdot A^i \cdot B^{N - i} = \sum_{i=0}^K S(K, i) \cdot (N)_i \cdot A^i \cdot (A + B)^{N - i}$$&lt;/p&gt;
&lt;p&gt;which can actually be obtained by starting the initial equation from $(Ax + B)^N$.&lt;/p&gt;
&lt;p&gt;You can now solve &lt;a href=&#34;https://codeforces.com/problemset/problem/1278/F&#34;&gt;Codeforces edu round problem Cards&lt;/a&gt; for $K \le 10^5$.&lt;/p&gt;
&lt;h2 id=&#34;moment-generating-function&#34;&gt;Moment Generating Function&lt;/h2&gt;
&lt;p&gt;Another way (and perhaps more elegant way) to arrive at that equation is to use the moment generating function. Let&lt;/p&gt;
&lt;p&gt;$$M_X(t) = \mathrm{E}(\exp(tX)) = \sum_{i=0}^\infty \frac{t^i \mathrm{E}(X^i)}{i!}$$&lt;/p&gt;
&lt;p&gt;Now, if you differentiate $M_X(t)$ for $k$ times, and substitute $t = 0$, you will end up with $\mathrm{E}(X^k)$.&lt;/p&gt;
&lt;p&gt;So if you start from $(A \exp(x) + B)^N$, then you differentiate $K$ times, you will obtain:&lt;/p&gt;
&lt;p&gt;$$\frac{\mathrm{d}^K}{\mathrm{d}x^K} (A \exp(x) + B)^N = \sum_{i = 0}^K S(K, i) \cdot (N)_i \cdot A^i \cdot (A \exp(x) + B)^{N - i} \cdot \exp(ix)$$&lt;/p&gt;
&lt;p&gt;Again, the formula above can be easily shown (roughly shown below) using induction following the recursion property of the Stirling second kind.&lt;/p&gt;
&lt;p&gt;Substituting $x = 0$, then you will arrive at the same equation.&lt;/p&gt;
&lt;h3 id=&#34;some-kind-of-proof&#34;&gt;Some kind of proof&lt;/h3&gt;
&lt;p&gt;We will prove that equation from the moment generating function section.&lt;/p&gt;
&lt;p&gt;Let $f(i) = (N)_i \cdot A^i \cdot (A \exp(x) + B)^{N - i} \cdot \exp(ix)$, which in particular $f(0) = (A \exp(x) + B)^N$.&lt;/p&gt;
&lt;p&gt;Then,&lt;/p&gt;
&lt;p&gt;$$\frac{\mathrm{d}f(i)}{\mathrm{d}x} = (N)_{i + 1} \cdot A^{i + 1} (A \exp(x) + B)^{N - i - 1} \exp((i+1)x) + i \cdot (N)_i \cdot A^i \cdot (A \exp(x) + B)^{N - i} \cdot \exp(ix)$$&lt;/p&gt;
&lt;p&gt;Substitute them back using $f$:&lt;/p&gt;
&lt;p&gt;$$\frac{\mathrm{d}f(i)}{\mathrm{d}x} = f(i + 1) + i \cdot f(i)$$&lt;/p&gt;
&lt;p&gt;Now write:&lt;/p&gt;
&lt;p&gt;$$\frac{\mathrm{d}^k}{\mathrm{d}x^k} (A \exp(x) + B)^N = \sum_{i = 0}^k c_{k, i} \cdot f(i)$$&lt;/p&gt;
&lt;p&gt;Differentiate it once, then you will get:&lt;/p&gt;
&lt;p&gt;$$\frac{\mathrm{d}^{k+1}}{\mathrm{d}x^{k+1}} (A \exp(x) + B)^N = \sum_{i = 0}^{k+1} (c_{k, i - 1} + i \cdot c_{k, i}) \cdot f(i)$$&lt;/p&gt;
&lt;p&gt;And notice that $c_{k + 1, i} = c_{k, i - 1} + i \cdot c_{k, i}$ is actually the same recurrence as the Stirling number of the second kind, which roughly end the proof.&lt;/p&gt;
</description>
		</item>
		<item>
			<title>Notes on Fast Fourier Transform</title>
			<link>https://prabowo02.github.io/posts/fft/</link>
			<pubDate>Thu, 17 Dec 2020 17:55:15 +0800</pubDate>
			<guid isPermaLink="true">https://prabowo02.github.io/posts/fft/</guid>
			<description>&lt;p&gt;This is not a tutorial. It&amp;rsquo;s just an overview for those who already (hopefully) understood FFT.
(Actually, more of a personal note to myself)&lt;/p&gt;
&lt;h3 id=&#34;so-what-is-fft&#34;&gt;So what is FFT?&lt;/h3&gt;
&lt;p&gt;DFT but fast&lt;/p&gt;
&lt;h3 id=&#34;what-dft-does&#34;&gt;What DFT does?&lt;/h3&gt;
&lt;p&gt;Converts a polynomial into point value forms where the points sampled are principal $n$-th root of unity.&lt;/p&gt;
&lt;h3 id=&#34;can-you-inverse-the-transformation&#34;&gt;Can you inverse the transformation?&lt;/h3&gt;
&lt;p&gt;Yes, by doing the exact same thing as DFT but the sampled points are inverted too, then divide the final result by $n$.&lt;/p&gt;
&lt;h3 id=&#34;how-to-do-dft&#34;&gt;How to do DFT?&lt;/h3&gt;
&lt;p&gt;Evaluate each sample point in $O(N)$, and you end up in $O(N^2)$ transformation.&lt;/p&gt;
&lt;h3 id=&#34;can-you-do-better&#34;&gt;Can you do better?&lt;/h3&gt;
&lt;p&gt;Yes, that&amp;rsquo;s when FFT comes in.&lt;/p&gt;
&lt;h3 id=&#34;how-to-fft&#34;&gt;How to FFT?&lt;/h3&gt;
&lt;p&gt;The most commonly used algorithm is Cooley-Tukey algorithm, and the DFT size is usually taken in the form of $2^k$. It is basically a Divide and Conquer algorithm, by separating the odd and even terms, and does FFT recursively. By doing some reordering using bit reversal, you can actually does an iterative version of it. Final complexity is $O(N \log N)$ without any additional space.
Details on FFT can be found in this &lt;a href=&#34;https://codeforces.com/blog/entry/43499&#34;&gt;Codeforces blog&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;how-does-fft-help-to-solve-problems&#34;&gt;How does FFT help to solve problems?&lt;/h3&gt;
&lt;p&gt;The main idea is sum-convolution (can also be viewed as polynomial multiplication). That is, given two sequences $a$ and $b$, for each pair of $i$, $j$, $a_i \times b_j$ is &amp;ldquo;contributed&amp;rdquo; to $c_{i + j}$, where $c$ is the convolution.
The way to do that is: $c = IFFT(FFT(a) * FFT(b))$, where $*$ is point-wise multiplication.&lt;/p&gt;
&lt;p&gt;Note that by default DFT is a cyclic convolution, i.e. $a_i b_j$ is actually contributed to $c_{(i + j) \bmod n}$ (in other words, the multiplication is in modulo $(x^n - 1)$). Therefore, to avoid &amp;ldquo;overflow&amp;rdquo;, you pad the polynoms with $0$s until the polynom size is of size $2^k ≥ |a| + |b|$.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://open.kattis.com/problems/aplusb&#34;&gt;An example problem&lt;/a&gt; on how FFT helps. For this problem, you create a polynom where the coefficient of $x^i$ is the number of elements in a that are equal to $i$. After that, you square the polynomial, then start processing from there.&lt;/p&gt;
&lt;p&gt;Sometimes FFT is closely related to string &amp;ldquo;matching&amp;rdquo; too. In this case, usually each alphabet is associated with a polynom where coefficient $x^i$ equals to $1$ if $s_i$ is equal to the associated alphabet, or $0$ otherwise. Here is &lt;a href=&#34;https://codeforces.com/problemset/problem/528/D&#34;&gt;an example&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Another time, a DP problem can be optimized using FFT too. This can be noticed when the transition is $O(N)$ and looks like a convolution. In the case of DP, often we mention the polynomial as (Ordinary) Generating Function. The coefficients of the OGF will be of the interest when arriving at the final answer.&lt;/p&gt;
&lt;p&gt;Talking about generating functions, there is also something called Exponential Generating Function. In EGF, the coefficient of $x^i$ is $\frac{\text{actual value}}{i!}$. And when you multiply, the contributed value is $\binom{i + j}{i} a_i b_j$.&lt;/p&gt;
&lt;h3 id=&#34;what-are-some-popular-generating-functions&#34;&gt;What are some popular generating functions?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;$(1 + x)^n$. OGF for binomial coefficients $(\binom{n}{0}, \binom{n}{1}, \dots, \binom{n}{n})$.&lt;/li&gt;
&lt;li&gt;$\frac{1}{1 - x}$. OGF for $(1, 1, \dots)$. This is handy if you want to get the &amp;ldquo;prefix sum&amp;rdquo; of a GF by simply divides it by $(1 - x)$.&lt;/li&gt;
&lt;li&gt;$\frac{1}{(1 - x)^k}$. OGF for $(\kern-.5em(\genfrac{}{}{0pt}{}{n}{k})\kern-.5em) = \binom{n + k - 1}{k - 1}$. Used for counting multisets.&lt;/li&gt;
&lt;li&gt;$\frac{x^k}{(1 - x)^{k + 1}}$. OGF for $\binom{n}{k}$. The &amp;ldquo;column&amp;rdquo; of binomial cofficients.&lt;/li&gt;
&lt;li&gt;$y = xy + xy^2 + 1 \implies y = \frac{1}{1 - x - x^2}$. OGF for Fibonacci number.&lt;/li&gt;
&lt;li&gt;$y = 1 + xy^2 \implies y = \frac{2}{1 + \sqrt{1 - 4x}}$. OGF for Catalan number.&lt;/li&gt;
&lt;li&gt;$\exp(x)$. EGF for $(1, 1, \dots)$.&lt;/li&gt;
&lt;li&gt;$\exp(\exp(x) - 1)$. EGF for Bell numbers. It can be used to count number of set partitions.&lt;/li&gt;
&lt;li&gt;$\prod_{i=0}^{n-1}(x + i)$. OGF for Stirling number first kind.&lt;/li&gt;
&lt;li&gt;$\exp(-x) \sum_{i=0}^n \frac{i^n x^i}{i!}$. OGF for Stirling number second kind, also known as Touchard polynomial.&lt;/li&gt;
&lt;li&gt;$\frac{(-\log(1 - x))^k}{k!}$. EGF for &amp;ldquo;column&amp;rdquo; Stirling number first kind. Note that $-\log(1 - x) = \sum \frac{x^i}{i}$.&lt;/li&gt;
&lt;li&gt;$\frac{(\exp(x) - 1)^k}{k!}$. EGF for &amp;ldquo;column&amp;rdquo; Stirling number second kind.&lt;/li&gt;
&lt;li&gt;$y \exp(y) = x$. Lambert W function. Also EGF for number of rooted enumerated trees. Can be computed using Lagrange–Bürmann formula.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;why-are-there-divisions-and-exponent&#34;&gt;Why are there divisions and exponent?&lt;/h3&gt;
&lt;p&gt;These are operations on formal power series. The idea is, if you want to compute $Q$ that satisfies $f(Q) = 0$, for some polynom $Q$ and function $f$, we can use the Newton&amp;rsquo;s method $Q_{n+1} = Q_n - \frac{f(P)}{f&amp;rsquo;(P)}$.&lt;/p&gt;
&lt;p&gt;For example, computing $Q = \frac{1}{P} \implies Q^{-1} - P = 0 \implies f(Q) = Q^{-1} - P$ &lt;br&gt;
$Q := Q - \frac{Q^{-1} - P}{-Q^{-2}} = Q + (Q - PQ) = 2Q - PQ^2$&lt;/p&gt;
&lt;p&gt;Another example, computing $Q = \sqrt{P} \implies Q^2 - P = 0 \implies f(Q) = Q^2 - P$ &lt;br&gt;
$Q := Q - \frac{Q^2 - P}{2Q} = \frac{1}{2}(Q + \frac{P}{Q})$&lt;/p&gt;
&lt;p&gt;In every iteration of the Newton&amp;rsquo;s method, the precision is doubled, i.e. the degree of $Q$ is improved from $n$ to $2n + 1$, and initially $Q$ is only a constant.&lt;/p&gt;
&lt;p&gt;And here are several operations along with their tricks:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Additions and subtractions are obvious.&lt;/li&gt;
&lt;li&gt;Multiplication done by FFT.&lt;/li&gt;
&lt;li&gt;Differentiation and integral are straightforward.&lt;/li&gt;
&lt;li&gt;$\frac{1}{P}$, $\sqrt{P}$, $\exp(P)$ can be done using Newton&amp;rsquo;s method.&lt;/li&gt;
&lt;li&gt;$\log(P) = \int \frac{P&amp;rsquo;}{P}$&lt;/li&gt;
&lt;li&gt;$P(x)^a = \exp(a \log(P(x)))$&lt;/li&gt;
&lt;li&gt;$\arctan(P) = \int \frac{1}{1 + P^2}$&lt;/li&gt;
&lt;li&gt;Generally, inverse trigonometric function can be computed from &lt;a href=&#34;https://en.wikipedia.org/wiki/Inverse_trigonometric_functions#Derivatives_of_inverse_trigonometric_functions&#34;&gt;their derivatives&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;$P^{-1}(x)$ i.e. the inverse function, can be done using Lagrange–Bürmann formula&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;what-about-modulo&#34;&gt;What about modulo?&lt;/h3&gt;
&lt;p&gt;You can find the details of division, modulo, multipoint evaluation, and interpolation in &lt;a href=&#34;https://drive.google.com/file/d/1B9BIfATnI_qL6rYiE5hY9bh20SMVmHZ7/view&#34;&gt;adamant&amp;rsquo;s lecture note&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;do-the-points-must-be-roots-of-unity&#34;&gt;Do the points must be roots of unity?&lt;/h3&gt;
&lt;p&gt;You can actually compute for $\{{z^i\}}_{i=0}^{n-1}$, for any complex number $z$. This is called Chirp Z-transform and can be done using Bluestein&amp;rsquo;s algorithm. The main idea is to write $ij = \binom{i + j}{2} - \binom{i}{2} - \binom{j}{2}$. &lt;br&gt;
Hence, $\sum(a_i z^{ik}) = \sum \left(a_i z^{-\binom{i}{2}} z^{\binom{i + k}{2}} \right) z^{-\binom{k}{2}}$, which is exactly a convolution and can be computed using FFT. &lt;a href=&#34;https://codeforces.com/problemset/problem/1054/H&#34;&gt;Example problem&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;can-we-compute-any-size-dft-quickly&#34;&gt;Can we compute any size DFT quickly?&lt;/h3&gt;
&lt;p&gt;Yes, by using CZT, and $z$ such that $z$ is primitive $n$-th root of unity where $n$ is the DFT size. One example problem that use DFT any size can be found on &lt;a href=&#34;https://codeforces.com/contest/901/problem/E&#34;&gt;Codeforces&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;must-the-polynomial-be-monic&#34;&gt;Must the polynomial be monic?&lt;/h3&gt;
&lt;p&gt;Multidimentional DFT can be done by performing DFT on each dimension one by one. An example problem can be found &lt;a href=&#34;https://codeforces.com/gym/102441/problem/E&#34;&gt;here&lt;/a&gt;. In this problem, &lt;span style=&#34;color:white&#34;&gt;you will need both sum-convolution for one variable, and xor-convolution for the other in a single polynomial&lt;/span&gt; (spoiler in white text).&lt;/p&gt;
&lt;h3 id=&#34;xor-convolution&#34;&gt;Xor-convolution?&lt;/h3&gt;
&lt;p&gt;Xor convolution means that $a_i b_j$ is contributed to $c_{i \oplus j}$. It is basically the standard DFT but multidimensional, and each dimension is DFT of size $2$. This is working because xor is basically addition in vector space $\bmod 2$.&lt;/p&gt;
&lt;h3 id=&#34;can-we-have-other-bitwise-convolutions&#34;&gt;Can we have other bitwise convolutions?&lt;/h3&gt;
&lt;p&gt;In XOR, you tranform $(u, v)$ to $(u + v, u - v)$. &lt;br&gt;
In AND, you tranform $(u, v)$ to $(u + v, v)$. After performing AND-tranform, you actually ends up with sum of supermasks. &lt;br&gt;
In OR, you tranform $(u, v)$ to $(u, u + v)$. After performing OR-tranform, you actually ends up with sum of submasks. &lt;br&gt;
In NAND, you perform AND, then do the bit inverting (i.e. swap coefficients of bit 0 and bit 1).&lt;/p&gt;
&lt;p&gt;An example problem that uses various binary gates can be found on &lt;a href=&#34;https://codeforces.com/contest/1033/problem/F&#34;&gt;Codeforces&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;must-dft-be-operated-in-complex&#34;&gt;Must DFT be operated in complex?&lt;/h3&gt;
&lt;p&gt;DFT works over an arbitrary ring, as long as you are using the principal $n$-th root of unity as the sampled points. Primitive $n$-th root is also principal $n$-th root. Since primitive roots are roots of the $n$-th cyclotomic polynomial, by ensuring your points satisfy $\Phi_n(x) = 0$, then DFT should work. &lt;a href=&#34;https://codeforces.com/problemset/problem/1103/E&#34;&gt;An example problem&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;can-we-compute-the-product-of-multiple-polynomials&#34;&gt;Can we compute the product of multiple polynomials?&lt;/h3&gt;
&lt;p&gt;Suppose that the sum of degrees of the given polynomials is $N$, then we can do either of the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use priority queue, and compute the multiplication of every two polynomials with the lowest degrees.&lt;/li&gt;
&lt;li&gt;Use Divide and Conquer, then split the polynomials to sum of degrees approximately N/2, then recurse&lt;/li&gt;
&lt;li&gt;Divide and Conquer, then split half of the polynomials, regardless of the degrees&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All of these run in $O(N \log^2 N)$. &lt;a href=&#34;https://codeforces.com/problemset/problem/1257/G&#34;&gt;This problem&lt;/a&gt; require this technique.&lt;/p&gt;
</description>
		</item>
		<item>
			<title>Factorial mod prime</title>
			<link>https://prabowo02.github.io/posts/factorial-mod-p/</link>
			<pubDate>Mon, 02 Nov 2020 18:00:15 +0800</pubDate>
			<guid isPermaLink="true">https://prabowo02.github.io/posts/factorial-mod-p/</guid>
			<description>&lt;p&gt;We are to compute $n! \bmod p$ in $O(\sqrt{p} \log p)$, where $p$ prime.&lt;/p&gt;
&lt;h2 id=&#34;basic-idea&#34;&gt;Basic Idea&lt;/h2&gt;
&lt;p&gt;If we define the polynomial $f(x) := \prod_{i=1}^n (x + i)$, then we can write $n! = f(0)$.&lt;/p&gt;
&lt;p&gt;Let $v := \lfloor \sqrt n \rfloor$ and $g(x) := \prod_{i=1}^v (x+i)$, then&lt;/p&gt;
&lt;p&gt;$$ n! = \left( \prod_{i=0}^{v-1} g(vi) \right) \prod_{i=v^2 + 1}^n i $$&lt;/p&gt;
&lt;p&gt;The latter part of the product can be computed in $O(\sqrt p)$. We will try to find a fast way to compute
$g(0), g(v), \dots, g(v(v-1))$.&lt;/p&gt;
&lt;h2 id=&#34;method&#34;&gt;Method&lt;/h2&gt;
&lt;h3 id=&#34;1-osqrt-p-log-p2&#34;&gt;1. $O(\sqrt p (\log p)^2)$&lt;/h3&gt;
&lt;p&gt;Using FFT multipoint evaluation, we can compute $g(0), \dots, g(v(v+1))$ simultaneously. However, this algorithm uses a lot of polynomial division, which has heavy constant factor, and the speed will not be much faster than $O(p)$.&lt;/p&gt;
&lt;h3 id=&#34;2-osqrt-p-log-p&#34;&gt;2. $O(\sqrt p \log p)$&lt;/h3&gt;
&lt;p&gt;$g(x)$ has roots $-1, -2, \dots, -v$ which is an arithmetic progression, and we want to evaluate $g(x)$ at $0, v, \dots, v(v-1)$ which is also an arithmetic progression. In this case, we will make use of Lagrange Interpolation.&lt;/p&gt;
&lt;p&gt;Next, for a fixed $d$, we define $g_d(x) := \prod_{i=1}^d (x+i)$. Suppose we are able to compute $g_d(0), g_d(v), \dots, g_d(dv)$, then we can compute $g_{2d}(0), g_{2d}(v), \dots, g_{2d}(2dv)$ in $O(d \log d)$. If we are able to achieve this, then we can achieve the desired complexity.&lt;/p&gt;
&lt;p&gt;Notice that $g_{2d}(x) = g_d(x) \cdot g_d(x + d)$. Let $G_d(i) := (g_d(i), g_d(v+i), \dots, g_d(dv + i))$, then from $G_d(0)$, we want to interpolate $G_d(d), G_d(dv), G_d(dv + d)$. This can be achieved using Lagrange Interpolation and FFT (NTT) in $O(d \log d)$ as described below.&lt;/p&gt;
&lt;p&gt;Let $h(x)$ be a $d$-degree polynomial and the values $h(0), h(1), \dots, h(d)$ are known, then the value $h(m + k)$ can be computed using Lagrange Interpolation (assuming $m + k - j$ has an inverse):&lt;/p&gt;
&lt;p&gt;$$
\begin{align*}
h(m + k) &amp;amp;= \sum_{i = 0}^d h(i) \prod_{j=0, i \neq j}^d \frac{m+k-j}{i-j} \\\
&amp;amp;= \left(\prod_{j=0}^d (m + k - j) \right) \left( \sum_{i=0}^d \frac{h(i)}{i! (d-i)! (-1)^{d-i}} \cdot \frac{1}{m + k - i} \right)
\end{align*}
$$&lt;/p&gt;
&lt;p&gt;Notice that the right parenthesis is actually a convolution, so $h(m), h(m+1), \dots, h(m+d)$ can be computed in $O(d \log d)$. To interpolate $G_d(a)$ from $G_d(0)$, it is enough to substitute $m := av^{-1}$.&lt;/p&gt;
&lt;p&gt;From the above, $n! \bmod p$ can be computed in $O(\sqrt p \log p)$.&lt;/p&gt;
</description>
		</item>
		<item>
			<title>Project Euler #100</title>
			<link>https://prabowo02.github.io/posts/project-euler-100/</link>
			<pubDate>Fri, 10 Jul 2020 00:24:26 +0800</pubDate>
			<guid isPermaLink="true">https://prabowo02.github.io/posts/project-euler-100/</guid>
			<description>&lt;p&gt;This post will give the analysis to &lt;a href=&#34;https://www.hackerrank.com/contests/projecteuler/challenges/euler100/problem&#34;&gt;Project Euler #100&lt;/a&gt; from hackerrank, which is an extended version from the &lt;a href=&#34;https://projecteuler.net/problem=100&#34;&gt;original&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;problem&#34;&gt;Problem&lt;/h2&gt;
&lt;p&gt;Given $P$, $Q$, and $M$, find smallest $n$ such that $\frac{b(b-1)}{n(n-1)} = \frac{P}{Q}$, where $b$ and $n$ are positive integers and $n &amp;gt; M$.&lt;/p&gt;
&lt;p&gt;Constraints:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$2 ≤ M ≤ 10^{15}$.&lt;/li&gt;
&lt;li&gt;$0 &amp;lt; P &amp;lt; Q ≤ 10^7$.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;
&lt;p&gt;To simplify matters, we assume $P$ and $Q$ are coprime. If they are not, simply divide both of them with their gcd.
The equation $\frac{b(b-1)}{n(n-1)} = \frac{P}{Q}$ can be rewritten as $Q(b(b-1)) = P(n(n-1)) \Rightarrow Q(2b-1)^2 - P(2n-1)^2 = Q - P$ by completing the square.&lt;/p&gt;
&lt;p&gt;Let $Q = qr^2$ where $r$ is the largest divisor of $Q$ such that $r^2 | Q$. Therefore $q$ is squarefree.
Multiplying both sides of the equation with $q$, we obtain:&lt;/p&gt;
&lt;p&gt;$$(qr(2b-1))^2 - Pq(2n-1)^2 = q(Q-P)$$&lt;/p&gt;
&lt;p&gt;Notice that this is actually the generalized Pell equation $x^2 - Dy^2 = N$, with $D = Pq$ and $N = q(Q-P)$.
Some readers may notice that multiplying both sides with $Q$ instead of $q$ will make the equation looks easier, but the reason to that may have to wait until the next few parts of the solution.&lt;/p&gt;
&lt;p&gt;There are two cases when solving the Pell equation $x^2 - Dy^2 = N$:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$D$ is a square.&lt;/li&gt;
&lt;li&gt;$D$ is not a square.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;d-is-a-square&#34;&gt;$D$ is a square&lt;/h3&gt;
&lt;p&gt;If $D$ is a square, that means $Pq$ is a square, or equivalently $PQ$ is also a square.
Let $d = \sqrt{PQ}$, $x = Q(2b-1)$, $y = (2n-1)$, then we can rewrite the equation $x^2 - PQy^2 = Q(Q-P)$ as:&lt;/p&gt;
&lt;p&gt;$(x - dy)(x + dy) = Q(Q-P)$&lt;/p&gt;
&lt;p&gt;Factoring $Q(Q-P)$ into $a \times b$ where $a$ and $b$ are integers, we solve these two simultaneous linear equations:&lt;/p&gt;
&lt;p&gt;$$x - dy = a$$
$$x + dy = b$$&lt;/p&gt;
&lt;p&gt;After solving these two equations for all $a$ and $b$, we obtain all solutions to $x$ and $y$. Hence, $b$ and $n$ can also be determined.&lt;/p&gt;
&lt;h3 id=&#34;d-is-not-a-square&#34;&gt;$D$ is not a square&lt;/h3&gt;
&lt;p&gt;If $D$ is not a square, apply the LMM algorithm (&lt;a href=&#34;http://www.jpr2718.org/pell.pdf&#34;&gt;Solving the generalized Pell equation by John P. Robertson&lt;/a&gt; page 16). The first part of the algorithm is to find all $z$ such that $z^2 = D \pmod {|m|}$ where $m = \frac{N}{f^2}$ and $f^2 | N$. Finding such $z$ may be hard in general, but there are a few special property on this specific equation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It can be seen that $q$ and $Q-P$ are coprime. Therefore we can split the congruence into two congruences and merge them later using CRT (Chinese Remainder Theorem).&lt;/li&gt;
&lt;li&gt;$f^2$ only divides $Q-P$ because $q$ is squarefree. Therefore we do not need to consider the divisors of $q$ when considering the equation $x^2 = Pq \mod q$.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;solving-x2--pq-mod-q&#34;&gt;Solving $x^2 = Pq \mod q$&lt;/h4&gt;
&lt;p&gt;It is obvious that $Pq = 0 \mod q$ because $q | Pq$. The congruence became $x^2 = 0 mod q$. Since q is squarefree, there is only one solution to $x$, which is $0$ (how convenient). This is the reason why we are not using the equation $x^2 - PQ = Q(Q-P)$, because solving $x^2 = 0 \mod Q$ may yield tens or hundreds of solutions.&lt;/p&gt;
&lt;h4 id=&#34;solving-x2--pq-mod-q-p&#34;&gt;Solving $x^2 = Pq \mod (Q-P)$&lt;/h4&gt;
&lt;p&gt;First, rewrite the congruence:&lt;/p&gt;
&lt;p&gt;$ \ \ \ \ \ \ \  x^2 = Pq \pmod{Q-P}$ &lt;br&gt;
$\Longrightarrow x^2 = Pq + q(Q-P) \pmod{Q-P}$ &lt;br&gt;
$\Longrightarrow x^2 = Qq \pmod {Q-P}$ &lt;br&gt;
$\Longrightarrow x^2 = (qr)^2 \pmod{Q-P}$&lt;/p&gt;
&lt;p&gt;This also works when the modulo is $\frac{Q-P}{f^2}$, we will obtain the same congruence $x^2 = (qr)^2 \pmod{\frac{Q-P}{f^2}}$.&lt;/p&gt;
&lt;p&gt;Since we already know one solution to $x$ (which is $qr$), then the other solutions can be determined quite easily.&lt;/p&gt;
&lt;p&gt;To solve $x^2 = a^2 \pmod m$, factor $m$ into its prime factors $p_1^{k_1} \times p_2^{k_2} \times \ldots \times p_n^{k_n}$.
Then solve $x^2 = a^2 \pmod{p^k}$ for each prime factor $p$ of $m$. Lastly, merge them using CRT.
Since $qr$ and $Q-P$ are coprime, we assume that $a$ and $m$ are coprime too.&lt;/p&gt;
&lt;h5 id=&#34;solving-x2--a2-pmod-2k&#34;&gt;Solving $x^2 = a^2 \pmod {2^k}$&lt;/h5&gt;
&lt;p&gt;Three cases:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$k = 1$: Only one solution to $x$, namely $x = 1$.&lt;/li&gt;
&lt;li&gt;$k = 2$: Two solutions, namely $x = 1$ and $x = 3$.&lt;/li&gt;
&lt;li&gt;$k &amp;gt; 2$: Four solutions, $x = a \pmod {2^k}$, $x = -a \pmod {2^k}$ $x = a + 2^{k-1} \pmod {2^k}$, $x = -a + 2^{k-1} \pmod {2^k}$.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Proves are left to the readers.&lt;/p&gt;
&lt;h5 id=&#34;solving-x2--a2-pmod-pk-where-p-odd-primes&#34;&gt;Solving $x^2 = a^2 \pmod {p^k}$ where $p$ odd primes.&lt;/h5&gt;
&lt;p&gt;Only two solutions exist: $x = a \pmod {p^k}$ and $x = -a \pmod {p^k}$.&lt;/p&gt;
&lt;p&gt;At this point, we already have a way to obtain all $z$ quickly.
Apply PQa with $P_0 = z$, $Q_0 = \frac{N}{f^2}$, $D = D$ until we find the first $(f \times G_i)^2 - (f \times Q_i)^2 = N$ (refer to the paper above for more explanations)&lt;/p&gt;
&lt;p&gt;We also have to find sufficiently many solutions to $x^2 - Dy^2 = 1$ to generate the solutions from the fundamentals above.
With these, the solution to the original equation can be found.&lt;/p&gt;
</description>
		</item>
		<item>
			<title>On Prime Counting in Sublinear Time</title>
			<link>https://prabowo02.github.io/posts/prime-counting/</link>
			<pubDate>Sun, 22 Dec 2019 14:00:39 +0800</pubDate>
			<guid isPermaLink="true">https://prabowo02.github.io/posts/prime-counting/</guid>
			<description>&lt;p&gt;We are to count how many prime numbers are there up to $N$ ($N \leq 10^{11}$).&lt;/p&gt;
&lt;h2 id=&#34;computation&#34;&gt;Computation&lt;/h2&gt;
&lt;p&gt;Let $\pi(N)$ be the number of primes up to $N$, and $f(n, p)$ be the number of integers $x$, for $2 \leq x \leq N$, such that it contains no prime factor $&amp;lt; p$.&lt;/p&gt;
&lt;p&gt;If $p$ is not prime, then $f(n, p) = f(n, p-1)$. Otherwise:&lt;/p&gt;
&lt;p&gt;\begin{align}
f(n, p) = f(n, p-1) - \left(f\Big(\big\lfloor\frac{n}{p} \big\rfloor, p-1\Big) - \pi(p-1)\right)
\tag{1}
\end{align}&lt;/p&gt;
&lt;p&gt;The value $f(\lfloor\frac{n}{p} \rfloor, p-1) - \pi(p-1)$ gives the number of integer $\leq N$ that has $p$ as its prime factor but no prime factor $&amp;lt; p$. In other words, it is subtracting $|\{pk | 1 \leq k \leq n/p, \forall_{\text{prime }q  &amp;lt; p} q \nmid k \}|$ from $f(n, p-1)$.&lt;/p&gt;
&lt;p&gt;Our goal is to compute $\pi(N) = f(N, \sqrt N)$.&lt;/p&gt;
&lt;h3 id=&#34;implementation&#34;&gt;Implementation&lt;/h3&gt;
&lt;p&gt;The idea is similar to the standard prime sieving: eliminate all numbers that is multiple of $2, 3, 5, \ldots, \sqrt N$.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Denote &lt;code&gt;dp[n]&lt;/code&gt; as an array to store the number of primes up to $n$, and initiate the array &lt;code&gt;dp[n]&lt;/code&gt; $= f(n, 1) = n-1$ for all unique values of $\lfloor \frac{N}{i} \rfloor$ (there are $O(\sqrt N) $such values).&lt;/li&gt;
&lt;li&gt;For every prime $p$ in the range $[2, N]$, update &lt;code&gt;dp[n] -= dp[n/p] - dp[p-1]&lt;/code&gt;, for all unique values of $n = \lfloor \frac{N}{i} \rfloor$ and $n \geq p^2$.
&lt;ul&gt;
&lt;li&gt;This is because when iterating prime $p$, all values of &lt;code&gt;dp[n]&lt;/code&gt; is storing $f(n, p-1)$. In particular, for $n &amp;lt; p^2$, it is already storing the number of primes up to &lt;code&gt;n&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Therefore, the operation &lt;code&gt;dp[n] -= dp[n/p] - dp[p-1]&lt;/code&gt; is actually performing the equation from $(1)$.&lt;/li&gt;
&lt;li&gt;By the end of this iteration, &lt;code&gt;dp[n]&lt;/code&gt; will store $f(n, p)$.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Return &lt;code&gt;dp[N]&lt;/code&gt; as our answer.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;pseudo-code&#34;&gt;Pseudo Code&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;primeCounting&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; N) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Ni &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sort_descending(unique([N&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;i &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i in [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; .. N]]))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (n: Ni) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    dp[n] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; n&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;; p&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;p &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; N; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;p) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (dp[p] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; dp[p&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]) &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// p is not a prime
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (n: Ni) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (n &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;i) &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      dp[n] &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; dp[n&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;p] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; dp[p];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; dp[N];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;complexity&#34;&gt;Complexity&lt;/h3&gt;
&lt;p&gt;It can be seen that the transition operation of $(1)$ is $O(1)$. Therefore, we just need to compute the space of $f(n, p)$.&lt;/p&gt;
&lt;p&gt;There are two cases:&lt;/p&gt;
&lt;h4 id=&#34;case-1-n-leq-sqrt-n&#34;&gt;Case 1: $n \leq \sqrt N$&lt;/h4&gt;
&lt;p&gt;All values of $n \leq \sqrt N$ exists in the set $\{ \lfloor \frac{N}{i} \rfloor \}$, and for each $n$, only $p^2 \leq n$ will be considered.&lt;/p&gt;
&lt;p&gt;Therefore the overall time complexity for this case:&lt;/p&gt;
&lt;p&gt;$$ \sum_{i=1}^{\sqrt N} \sqrt i = O\left( \int_1^{\sqrt N} \sqrt x \, dx \right) = O(N^{3/4})$$&lt;/p&gt;
&lt;h4 id=&#34;case-2-n--sqrt-n&#34;&gt;Case 2: $n &amp;gt; \sqrt N$&lt;/h4&gt;
&lt;p&gt;The values of $n$ in this case is $\frac{N}{1}, \frac{N}{2}, \ldots, \frac{N}{\sqrt N}$. Since every $n$ needs to consider all $p^2 \leq n$, the time complexity for this case is:&lt;/p&gt;
&lt;p&gt;$$ \sum_{i=1}^{\sqrt N} \sqrt{\frac{N}{i}} = O\left(\sqrt N \int_1^{\sqrt N} \frac{1}{\sqrt x} \, dx \right) = O(N^{3/4})$$&lt;/p&gt;
&lt;h4 id=&#34;total-complexity&#34;&gt;Total Complexity&lt;/h4&gt;
&lt;p&gt;Since the complexity for both cases are the same, the total complexity is $O(N^{3/4})$&lt;/p&gt;
&lt;h2 id=&#34;remarks&#34;&gt;Remarks&lt;/h2&gt;
&lt;h3 id=&#34;speeding-up-computation&#34;&gt;Speeding Up Computation&lt;/h3&gt;
&lt;p&gt;It seems that we can speed up the computation by precomputing the first few prime numbers using the standard sieve of eratosthenes. Precompute the first $f(n, p)$ for $n \leq N^{2/3}$, then for the rest of the $n$, use the same iteration as above. This should run in a little more than $O(N^{2/3})$.&lt;/p&gt;
&lt;h3 id=&#34;other-usages&#34;&gt;Other Usages&lt;/h3&gt;
&lt;p&gt;With a few tweaks, we can compute the following with the same method:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sum of prime up to $n$.&lt;/li&gt;
&lt;li&gt;Sum of prime of the form $4k + 1$ up to $n$.&lt;/li&gt;
&lt;li&gt;Totient summatory function up to $n$.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Looks like it is also possible to further generalize this method using the Dirichlet Hyperbola method.&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Prime-counting_function#The_Meissel%E2%80%93Lehmer_algorithm&#34;&gt;The Meissel-Lehmer algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://math.stackexchange.com/questions/316376/how-to-calculate-these-totient-summation-sums-efficiently&#34;&gt;Efficient Totient Summatory Function&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://math.stackexchange.com/questions/1378286/find-the-sum-of-all-primes-smaller-than-a-big-number&#34;&gt;Sum of primes smaller than a big number&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Dirichlet_hyperbola_method&#34;&gt;Dirichlet Hyperbola Method&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
		</item>
		<item>
			<title>Binomial Modulo Prime Power</title>
			<link>https://prabowo02.github.io/posts/binomial-mod-pe/</link>
			<pubDate>Wed, 04 Dec 2019 16:03:30 +0800</pubDate>
			<guid isPermaLink="true">https://prabowo02.github.io/posts/binomial-mod-pe/</guid>
			<description>&lt;p&gt;This is an attempt to translate &lt;a href=&#34;https://min-25.hatenablog.com/entry/2017/11/01/185400&#34;&gt;min_25&amp;rsquo;s article&lt;/a&gt; with the help of Google Translate, and with a bit of modification.&lt;/p&gt;
&lt;p&gt;Our goal is to solve ${n \choose m} \pmod{p^e}$, ($n, m, p^e &amp;lt; 10^{300}$, $p$: prime number).&lt;/p&gt;
&lt;p&gt;The method differ from Andrew Granville&amp;rsquo;s Binomial Coefficients modulo prime powers (&lt;a href=&#34;https://web.archive.org/web/20170202003812/http://www.dms.umontreal.ca/~andrew/PDF/BinCoeff.pdf&#34;&gt;BinCoeff.pdf&lt;/a&gt;). &lt;br&gt;
After precomputation, the number of operation to compute ${n \choose m} \pmod{p^e}$ is reduced from $O\left(e^2\left(\frac{\log n}{\log p} + \min(\log n, \log p)\right)\right)$ to $O(e \log n)$.&lt;/p&gt;
&lt;p&gt;For the rest of the article, denote ${n \brack m}$ as &lt;a href=&#34;https://en.wikipedia.org/wiki/Stirling_numbers_of_the_first_kind&#34;&gt;Stirling number of the first kind&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;computation-method&#34;&gt;Computation Method&lt;/h3&gt;
&lt;p&gt;Define $(n!)_p$ as the product of all positive integers $i \not\equiv 0 \pmod p$ for all $1 \leq i \leq n$. Our goal is to compute $(n!)_p \pmod {p^e}$.&lt;/p&gt;
&lt;p&gt;Let $n = up + v$ where $u, v$ non-negative integers and $0 \leq v &amp;lt; p$.&lt;/p&gt;
&lt;p&gt;For simplicity, we assume that $e &amp;lt; p$,&lt;/p&gt;
&lt;p&gt;$$
\begin{align*}
((up+v)!)_p &amp;amp;= \left( \prod_{i=0}^{u-1} \prod_{j=1}^{p-1} (ip+j) \right) \cdot \prod_{j=1}^v (up + j) \\\
&amp;amp;\equiv \left(\prod_{i=0}^{u-1} \left( \sum_{k=0}^{e-1} (ip)^k {p \brack {k+1}}\right)\right) \cdot \left(\sum_{k=0}^{e-1}(up)^k {{v+1} \brack {k+1}}\right) \pmod {p^e} \\\
&amp;amp;= {p \brack 1}^u \left(\prod_{i=0}^{u-1}\left( 1 + \sum_{k=1}^{e-1} \frac{{p \brack {k+1}}}{{p \brack 1}}(ip)^k \right) \right) \cdot \left( \sum_{k=0}^{e-1} (up)^k {{v+1} \brack {k+1}} \right) \\\
&amp;amp;= {p \brack 1}^u f_{p,e}(u) \left( \sum_{k=0}^{e-1} (up)^k {{v+1} \brack {k+1}} \right)
\end{align*}
$$&lt;/p&gt;
&lt;p&gt;It can be shown that $f_{p, e}$ is a polynomial of degree $(2e - 2)$ (proven below). By calculating the value of $f_{p, e}(0), \ldots, f_{p, e}(2e-2)$, the value of $f_{p, e}(u)$ can be computed in $O(e \log n)$ using &lt;a href=&#34;https://en.wikipedia.org/wiki/Lagrange_polynomial&#34;&gt;Lagrange interpolation&lt;/a&gt; (in $O(e)$ if you precompute the modular inverses).&lt;/p&gt;
&lt;h4 id=&#34;implementation-and-time-complexity&#34;&gt;Implementation and Time Complexity&lt;/h4&gt;
&lt;p&gt;First, compute the &lt;a href=&#34;https://en.wikipedia.org/wiki/P-adic_order&#34;&gt;$p$-adic valuation&lt;/a&gt; of ${n \choose m}$. If it is not less than $e$, then the modulo is 0. Otherwise, we factor out all the $p$ factors in $n!, m!, (n-m)!$ then we compute the factorials, and multiply with the $p$ factors at the end of the ${n \choose m}$ computation below.&lt;/p&gt;
&lt;p&gt;After the 0 case handling, we do the steps as follow:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;${n \brack m} (1 \leq n \leq p, 1 \leq m \leq \min(p, e))$ is precomputed in $O(p \cdot \min(p, e))$&lt;/li&gt;
&lt;li&gt;$f_{p, e}(0), \ldots, f_{p, e}(2e-2)$ for interpolation are precomputed in $O(e \cdot \min(p, e) + e \log p)$&lt;/li&gt;
&lt;li&gt;Computation of $n!$ without the factor $p$ can be done by $\sum_{k=0}^\infty \left(\left\lfloor\frac{n}{p^k}\right\rfloor_p\right)!$ in $O(e \log n)$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In total, there are around $O(pe + e^2 + e \log n)$ time complexity to compute ${n \choose m}$&lt;/p&gt;
&lt;h4 id=&#34;proof-that-f_p-e-is-a-polynomial&#34;&gt;Proof that $f_{p, e}$ is a polynomial&lt;/h4&gt;
&lt;p&gt;For any $e, p$ $(e \geq 1, p \geq 2)$, let $a_k$ be a rational number that exists under modulo $p$. Let,&lt;/p&gt;
&lt;p&gt;$$ g(x, u) := \prod_{i=0}^{u-1} \left( 1 + \sum_{k=1}^{e-1} a_k (xi)^k \right) $$&lt;/p&gt;
&lt;p&gt;Let $b_k$ be some other rational number satisfying:&lt;/p&gt;
&lt;p&gt;$$
\begin{align*}
\log(g(x, u)) &amp;amp;= \sum_{i=0}^{u-1} \log\left( 1 + \sum_{k=1}^{e-1} a_k(xi)^k \right) \\\
&amp;amp;= \sum_{i=0}^{u-1} \sum_{k=0}^\infty b_k x^k i^k \\\
&amp;amp;= \sum_{k=1}^\infty b_k x^k s_k(u)
\end{align*}
$$&lt;/p&gt;
&lt;p&gt;where $s_k(x) = \sum_{i=0}^x i^k$ is a polynomial of degree $k+1$. Continuing from above,&lt;/p&gt;
&lt;p&gt;$$
\begin{align*}
g(x, u) &amp;amp;= \exp\left( \sum_{k=1}^\infty b_k x^k s_k(u) \right) \\\
&amp;amp;= 1 + \sum_{k=1}^\infty t_k(u) x^k
\end{align*}
$$&lt;/p&gt;
&lt;p&gt;where $t_k(u)$ is a polynomial of degree $2k$, because the highest polynomial degree obtained at $x^k$ is from $(b_1 x s_1(u))^k$. The coefficients of $t_k(u)$ are also rational number which exists under modulo $p$.&lt;/p&gt;
&lt;p&gt;Substituting $x = p$ gives us the polynomial of $f_{p, e}(u)$:&lt;/p&gt;
&lt;p&gt;$$ g(p, u) \equiv 1 + \sum_{k=1}^{e-1} t_k(u) \cdot p^k \pmod{p^e} $$&lt;/p&gt;
&lt;p&gt;Therefore, $f_{p, e}(x)$ is a polynomial of degree $(2e - 2)$.&lt;/p&gt;
&lt;h3 id=&#34;remark&#34;&gt;Remark&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;If $p$ is prime, ${p \brack i}$ $(2 \leq i &amp;lt; p)$ is divisible by $p$.&lt;/li&gt;
&lt;li&gt;If $p \geq 5$, ${p \brack 2}$ is divisible by $p^2$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Using these properties, looks like it is possible to further reduce the degree of $f_{p, e}(x)$.&lt;/p&gt;
&lt;h3 id=&#34;source-codes&#34;&gt;Source Codes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;min_25&amp;rsquo;s implementation using &lt;a href=&#34;https://gist.github.com/min-25/a5496354e10064a581d6b0c52c727a26&#34;&gt;Python&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;My implementation using &lt;a href=&#34;https://github.com/prabowo02/CP/blob/master/binomial_mod_pe.cpp&#34;&gt;C++&lt;/a&gt; (but it is not using big integer, only &lt;code&gt;__int128&lt;/code&gt;, so it can only support for $n$ up to $10^{18}$).&lt;/li&gt;
&lt;/ul&gt;
</description>
		</item>
		<item>
			<title>Project Euler #242</title>
			<link>https://prabowo02.github.io/posts/project-euler-242/</link>
			<pubDate>Fri, 29 Nov 2019 12:15:14 +0800</pubDate>
			<guid isPermaLink="true">https://prabowo02.github.io/posts/project-euler-242/</guid>
			<description>&lt;p&gt;This post will give the analysis to &lt;a href=&#34;https://www.hackerrank.com/contests/projecteuler/challenges/euler242/problem&#34;&gt;Project Euler #242&lt;/a&gt; from hackerrank, which is an extended version from the &lt;a href=&#34;https://projecteuler.net/problem=242&#34;&gt;original&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;problem-statement&#34;&gt;Problem Statement&lt;/h3&gt;
&lt;p&gt;Given 5 integers $m$, $r$, $n$, $k$, and $M$, count the number of k-subsets of $\{1, 2, \ldots, n\}$ such that the sum of the subset is $r \pmod m$. Let the answer be $S$, output $S \times m$ modulo $M$.&lt;/p&gt;
&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;$2 \leq m \leq 10^{11}$&lt;/li&gt;
&lt;li&gt;$0 \leq r \leq m$&lt;/li&gt;
&lt;li&gt;$1 \leq k \leq n \leq 10^{18}$&lt;/li&gt;
&lt;li&gt;For each positive divisor $d$ of $m$: $n \mod d \leq k \mod d$&lt;/li&gt;
&lt;li&gt;$2 \leq M \leq 2^{62}$&lt;/li&gt;
&lt;li&gt;The largest prime factor of $M$ is less than $10^5$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;
&lt;p&gt;This is actually an extended version of &lt;a href=&#34;https://www.imo-official.org/year_info.aspx?year=1995&#34;&gt;IMO 1995 P6&lt;/a&gt; (having $m = p$, $n = 2p$, $k = p$, $r = 0$). A discussion to this problem can be found in &lt;a href=&#34;https://artofproblemsolving.com/community/c6h15112p107230&#34;&gt;AOPS&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Back to the original problem, consider the generating function $(1 + xy)(1 + xy^2) \ldots (1 + xy^n)$. Our answer will be the sum of coefficients of $x^k y^r, x^k y^{r+m}, x^k y^{r+2m}, \ldots$.&lt;/p&gt;
&lt;p&gt;To get this sum, we use the &lt;a href=&#34;https://en.wikipedia.org/wiki/Series_multisection&#34;&gt;Series Multisection&lt;/a&gt; formula on the y coefficients, then our generating function become:&lt;/p&gt;
&lt;p&gt;$$\frac{1}{m} \sum_{l=0}^{m-1} \left( \omega^{-lr} \prod_{i=1}^n (1 + x\omega^{li}) \right)$$&lt;/p&gt;
&lt;p&gt;where $\omega$ is the primitive $m$-th root of unity. Since the final answer will be multiplied by $m$, the $\frac{1}{m}$ will be ignored for the rest of this post. Now our goal is to find the coefficient of $x^k$ from that equation.&lt;/p&gt;
&lt;p&gt;Using the &lt;a href=&#34;http://mathworld.wolfram.com/CauchyBinomialTheorem.html&#34;&gt;Cauchy Binomial Theorem&lt;/a&gt;, we convert our equation above to:&lt;/p&gt;
&lt;p&gt;$$\sum_{l=0}^{m-1} \left( \omega^{-lr} \sum_{i=0}^n x^i \omega^{li(i+1)/2} {n \brack i}_{\omega^l} \right)$$&lt;/p&gt;
&lt;p&gt;Since we only care with the $x^k$ coefficient, then the answer to our original problem is the evaluation of:&lt;/p&gt;
&lt;p&gt;$$ \sum_{i=0}^{m-1} \left( (\omega^{i})^{k(k+1)/2 - r} {n \brack k}_{\omega^i} \right) $$&lt;/p&gt;
&lt;p&gt;We will compute the sum for each primitive of $\omega^i$ separately. Denote $\omega_d$ as the primitive $d$-th root of unity. Also note the &lt;a href=&#34;https://www.math.upenn.edu/~peal/polynomials/q-analogues.htm#prelimQanaloguesQLucas&#34;&gt;q-Lucas theorem&lt;/a&gt;: ${n \brack k}_{\omega_d} = {\lfloor n/d \rfloor \choose \lfloor k/d \rfloor } {n \mod d \brack k \mod d}_{\omega_d}$. &lt;br&gt;
Since $n \mod d \leq k \mod d$, the value of ${n \mod d \brack k \mod d} = 1$ if $n \equiv k \pmod d$, $0$ otherwise. &lt;br&gt;
With these in mind, we rewrite our equation to:&lt;/p&gt;
&lt;p&gt;$$ \sum_{d|m} \left( \sum_{(d, i) = 1}^d (\omega_d^i)^{k(k+1)/2 - r}  {n \choose k}[n \equiv k \pmod d] \right) $$&lt;/p&gt;
&lt;p&gt;where $[]$ is the &lt;a href=&#34;https://en.wikipedia.org/wiki/Iverson_bracket&#34;&gt;Iverson bracket&lt;/a&gt;. Recall that the sum of $k$-th power of the $d$-th root of unity is $\frac{\mu(d / \gcd(k, d)) \varphi(d)}{\varphi(d / \gcd(k, d))}$, where $\mu$ is the &lt;a href=&#34;https://en.wikipedia.org/wiki/M%C3%B6bius_function&#34;&gt;Möbius function&lt;/a&gt; and $\varphi$ is the &lt;a href=&#34;https://en.wikipedia.org/wiki/Euler%27s_totient_function&#34;&gt;Euler&amp;rsquo;s Totient function&lt;/a&gt;. &lt;br&gt;
Therefore, our final answer is:&lt;/p&gt;
&lt;p&gt;$$ \sum_{d|m} \left( \frac{\mu\left(\frac{d}{\gcd(k(k+1)/2 - r, d)}\right) \varphi(d)}{\varphi\left(\frac{d}{\gcd(k(k+1)/2 - r, d)}\right)} {n \choose k}[n \equiv k \pmod d] \right) $$&lt;/p&gt;
&lt;p&gt;And now, for the computational part. Compute the final sum for every prime factor of $M$, then combine the answers using &lt;a href=&#34;https://en.wikipedia.org/wiki/Chinese_remainder_theorem&#34;&gt;Chinese Remainder Theorem&lt;/a&gt;. The computation of binomial theorem modulo $p^e$ can be computed in $O(e(p + e + \log n))$, which is described in this &lt;a href=&#34;https://prabowo02.github.io/posts/binomial-mod-pe&#34;&gt;post&lt;/a&gt;. &lt;br&gt;
The computation of the divisors of $m$ and all its mobius and euler totient values can be computed in $O(\sqrt m)$&lt;/p&gt;
&lt;p&gt;Therefore, the overall complexity is $O(\sqrt m + \log M \log n)$.&lt;/p&gt;
</description>
		</item>
	</channel>
</rss>
